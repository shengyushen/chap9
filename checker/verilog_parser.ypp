%skeleton "lalr1.cc" /* -*- C++ -*- */
 /*%require "3.0.4"*/
 /*as of writing this, I am using 3.0.2*/
/*creating .h file*/
%defines "verilog_parser.h"
/*new parser class name and its constructor's parameter*/
%define parser_class_name {verilog_parser}
/*it will automatically creat a copy member of the same name , so we can refer to it latter*/
/*%parse-param {}  */
%initial-action
{
};
/*defining symbol_type that can be return from lex together with it location using make_<token name>*/
%define api.token.constructor
%define api.value.type variant
/*checking improper syntax structure*/
%define parse.assert
/* Enable run-time traces (yydebug).  */
%define parse.trace
%define parse.error verbose
%locations

%define api.token.prefix {TOK_}
%token
END  0  "end of file"
OP2_ADD    "+"
;

%token <int> UNSIGNED_NUMBER 
%type  <int> exp

%code{
/* this "connects" the bison parser in the driver to the flex scanner class
 * object. it defines the yylex() function call to pull the next token from the
 * current lexer object of the driver context. */
using namespace std;
extern yy::verilog_parser::symbol_type yylex();
}

%%

%start st;
st:  exp  { cout<<"get exp "<<$1<<endl; };

%left "+";
exp:
exp "+" exp   { $$ = $1 + $3; }
| UNSIGNED_NUMBER      { std::swap ($$, $1); };

%%
void
yy::verilog_parser::error (const location_type& l,
                          const std::string& m)
{
	std::cerr<<"FATAL : "<<m<<std::endl;
	std::cerr<<l<<std::endl;
}
