%skeleton "lalr1.cc" /* -*- C++ -*- */
 /*%require "3.0.4"*/
 /*as of writing this, I am using 3.0.2*/
/*creating .h file*/
%defines "verilog_parser.h"
/*new parser class name and its constructor's parameter*/
%define parser_class_name {verilog_parser}
/*it will automatically creat a copy member of the same name , so we can refer to it latter*/
%parse-param { std::string * filename}  
%initial-action
{
	@$.initialize (filename);
};
/*defining symbol_type that can be return from lex together with it location using make_<token name>*/
%define api.token.constructor
%define api.value.type variant
/*checking improper syntax structure*/
%define parse.assert
/* Enable run-time traces (yydebug).  */
%define parse.trace
%define parse.error verbose
%locations

%define api.token.prefix {TOK_}


%token END  0  "end of file";

%token KEY_ALWAYS;
%token KEY_AND;
%token KEY_ASSIGN;
%token KEY_AUTOMATIC;
%token KEY_BEGIN;
%token KEY_BUF;
%token KEY_BUFIF0;
%token KEY_BUFIF1;
%token KEY_CASE;
%token KEY_CASEX;
%token KEY_CASEZ;
%token KEY_CELL;
%token KEY_CMOS;
%token KEY_CONFIG;
%token KEY_DEASSIGN;
%token KEY_DEFAULT;
%token KEY_DEFPARAM;
%token KEY_DESIGN;
%token KEY_DISABLE;
%token KEY_EDGE;
%token KEY_ELSE;
%token KEY_END;
%token KEY_ENDCASE;
%token KEY_ENDCONFIG;
%token KEY_ENDFUNCTION;
%token KEY_ENDGENERATE;
%token KEY_ENDMODULE;
%token KEY_ENDPRIMITIVE;
%token KEY_ENDSPECIFY;
%token KEY_ENDTABLE;
%token KEY_ENDTASK;
%token KEY_EVENT;
%token KEY_FOR;
%token KEY_FORCE;
%token KEY_FOREVER;
%token KEY_FORK;
%token KEY_FUNCTION;
%token KEY_GENERATE;
%token KEY_GENVAR;
%token KEY_HIGHZ0;
%token KEY_HIGHZ1;
%token KEY_IF;
%token KEY_IFNONE;
%token KEY_INCDIR;
%token KEY_INCLUDE;
%token KEY_INITIAL;
%token KEY_INOUT;
%token KEY_INPUT;
%token KEY_INSTANCE;
%token KEY_INTEGER;
%token KEY_JOIN;
%token KEY_LARGE;
%token KEY_LIBLIST;
%token KEY_LIBRARY;
%token KEY_LOCALPARAM;
%token KEY_MACROMODULE;
%token KEY_MEDIUM;
%token KEY_MODULE;
%token KEY_NAND;
%token KEY_NEGEDGE;
%token KEY_NMOS;
%token KEY_NOR;
%token KEY_NOSHOWCANCELLED;
%token KEY_NOT;
%token KEY_NOTIF0;
%token KEY_NOTIF1;
%token KEY_OR;
%token KEY_OUTPUT;
%token KEY_PARAMETER;
%token KEY_PMOS;
%token KEY_POSEDGE;
%token KEY_PRIMITIVE;
%token KEY_PULL0;
%token KEY_PULL1;
%token KEY_PULLDOWN;
%token KEY_PULLUP;
%token KEY_PULSESTYLE_ONEVENT;
%token KEY_PULSESTYLE_ONDETECT;
%token KEY_RCMOS;
%token KEY_REAL;
%token KEY_REALTIME;
%token KEY_REG;
%token KEY_RELEASE;
%token KEY_REPEAT;
%token KEY_RNMOS;
%token KEY_RPMOS;
%token KEY_RTRAN;
%token KEY_RTRANIF0;
%token KEY_RTRANIF1;
%token KEY_SCALARED;
%token KEY_SHOWCANCELLED;
%token KEY_SIGNED;
%token KEY_SMALL;
%token KEY_SPECIFY;
%token KEY_SPECPARAM;
%token KEY_STRONG0;
%token KEY_STRONG1;
%token KEY_SUPPLY0;
%token KEY_SUPPLY1;
%token KEY_TABLE;
%token KEY_TASK;
%token KEY_TIME;
%token KEY_TRAN;
%token KEY_TRANIF0;
%token KEY_TRANIF1;
%token KEY_TRI;
%token KEY_TRI0;
%token KEY_TRI1;
%token KEY_TRIAND;
%token KEY_TRIOR;
%token KEY_TRIREG;
%token KEY_UNSIGNED;
%token KEY_USE;
%token KEY_UWIRE;
%token KEY_VECTORED;
%token KEY_WAIT;
%token KEY_WAND;
%token KEY_WEAK0;
%token KEY_WEAK1;
%token KEY_WHILE;
%token KEY_WIRE;
%token KEY_WOR;
%token KEY_XNOR;
%token KEY_XOR;

%token KEY_PATHPULSE;

%token
/*op for both unary and binary*/
OP2_ADD                      "+"	 
OP2_SUB                      "-"	 
OP2_AND                      "&"	 
OP2_OR                       "|"	 
OP2_XOR                      "^"	 
OP2_XNOR                     /*it have two representation*/
/*ops for unary*/
OP1_LOGIC_NEG                "!"	 
OP1_BITWISE_NEG              "~"	
OP1_REDUCE_NAND              "~&"
OP1_REDUCE_NOR               "~|"
/*ops for binary*/
OP2_MULTIPLE                 "*"		
OP2_DIV                      "/"		
OP2_MOD                      "%"		
OP2_EQU2                     "=="	
OP2_NEQ2                     "!="	
OP2_EQU3                     "==="	
OP2_NEQ3                     "!=="	
OP2_AND2                     "&&"	
OP2_OR2                      "||"	
OP2_POWER                    "**"	
OP2_LT                       "<"		
OP2_LE                       "<="	
OP2_GT                       ">"		
OP2_GE                       ">="	
OP2_LOGICAL_RIGHTSHIFT       ">>"	
OP2_LOGICAL_LEFTSHIFT        "<<"	
OP2_ARITHMETIC_RIGHTSHIFT    ">>>"	
OP2_ARITHMETIC_LEFTSHIFT     "<<<"	
OP2_QUESTION                 "?"		
/*other*/
LPARENT                      "("	
LPARENTSTART                 "(*"
RPARENT                      ")"	
RPARENTSTART                 "*)"
COMMA                        ","	
SEMICOLON                    ";"	
COLON                        ":"	
LSQUARE                      "["	
RSQUARE                      "]"	
EQU1                         "="	
LBRACE                       "{"	
RBRACE                       "}"	
PERIOD                       "."	
AT                           "@"	
JING                         "#"	
ADDRANGE                     "+:"
SUBRANGE                     "-:"
DOLLOR                       "$"	
IMPLY                        "->"
IMPLY2                       "=>"
IMPLYSTART                   "*>"
;

%token <unsigned int> UNSIGNED_NUMBER;
%token <std::tuple<unsigned int , unsigned int>> UNSIGNED_NUMBER_size
%token <std::tuple<unsigned int,std::string        >> OCTAL_NUMBER
%token <std::tuple<unsigned int,std::string        >> BINARY_NUMBER
%token <std::tuple<unsigned int,std::string        >> HEX_NUMBER
%token <std::string> REAL_NUMBER
/*A.8.8 Strings*/
%token <std::string> STRING
/*A.9.3 Identifiers*/
%token <std::string> ESCAPED_IDENTIFIER
%token <std::string> SIMPLE_IDENTIFIER
%token <std::string> SYSTEM_TASK_FUNCTION_IDENTIFIER

%right OP2_QUESTION COLON
%left  OP2_OR2
%left  OP2_AND2
%left  OP2_OR
%left  OP2_XOR OP2_XNOR
%left  OP2_AND
%left  OP2_EQU2 OP2_NEQ2 OP2_EQU3 OP2_NEQ3
%left  OP2_LT OP2_LE OP2_GT OP2_GE
%left  OP2_LOGICAL_LEFTSHIFT OP2_LOGICAL_RIGHTSHIFT OP2_ARITHMETIC_LEFTSHIFT OP2_ARITHMETIC_RIGHTSHIFT
%left  OP2_ADD OP2_SUB
%left  OP2_MULTIPLE OP2_DIV OP2_MOD
%left  OP2_POWER
/*unary only operator*/
%left  OP1_LOGIC_NEG  OP1_BITWISE_NEG OP1_REDUCE_NAND OP1_REDUCE_NOR
/*unary operator symbol that maybe used as binary operator*/
%nonassoc   OP1_ADD OP1_SUB OP1_AND OP1_OR OP1_XOR OP1_XNOR

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::description>>>> source_text
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::description>>>> description_list
%type <std::shared_ptr<Verilogast::description>> description

%type <std::shared_ptr<Verilogast::module_declaration>> module_declaration

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::attribute_instance>>>>  attribute_instance_list
%type <std::shared_ptr<Verilogast::attribute_instance>>  attribute_instance

%type <std::shared_ptr<Verilogast::identifier>>  module_identifier
%type <std::shared_ptr<Verilogast::identifier>>  port_identifier
%type <std::shared_ptr<Verilogast::identifier>>  net_identifier
%type <std::shared_ptr<Verilogast::identifier>>  parameter_identifier
%type <std::shared_ptr<Verilogast::identifier>>  real_identifier
%type <std::shared_ptr<Verilogast::identifier>>  variable_identifier
%type <std::shared_ptr<Verilogast::identifier>>  event_identifier
%type <std::shared_ptr<Verilogast::identifier>>  identifier
%type <std::shared_ptr<Verilogast::identifier>>  function_identifier
%type <std::shared_ptr<Verilogast::identifier>>  task_identifier
%type <std::shared_ptr<Verilogast::identifier>>  module_instance_identifier
%type <std::shared_ptr<Verilogast::identifier>>  genvar_identifier
%type <std::shared_ptr<Verilogast::identifier>>  generate_block_identifier
%type <std::shared_ptr<Verilogast::identifier>>  colon_generate_block_identifier_opt
%type <std::shared_ptr<Verilogast::identifier>>  block_identifier
%type <std::shared_ptr<Verilogast::identifier>>  attr_name
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::identifier>>>>  list_of_genvar_identifiers
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::identifier>>>>  comma_genvar_identifier_list
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::identifier>>>>  list_of_port_identifiers
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::identifier>>>>  comma_port_identifier_list

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::parameter_declaration_gen>>>> module_parameter_port_list_opt
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::parameter_declaration_gen>>>> module_parameter_port_list
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::parameter_declaration_gen>>>> comma_parameter_declaration_list
%type <std::shared_ptr<Verilogast::parameter_declaration_gen>> parameter_declaration_gen

%type <std::shared_ptr<Verilogast::port_expression>> port_expression_opt
%type <std::shared_ptr<Verilogast::port_expression>> port_expression

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::port>>>> list_of_ports
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::port>>>> comma_port_list
%type <std::shared_ptr<Verilogast::port>> port

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::module_item>>>> module_item_list
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::module_item>>>> module_or_generate_item_list
%type <std::shared_ptr<Verilogast::module_item>> module_item
%type <std::shared_ptr<Verilogast::module_item>> module_or_generate_item
%type <std::shared_ptr<Verilogast::module_item>> non_port_module_item

%type <int>  module_keyword

%type <std::shared_ptr<Verilogast::io_type>>   io_type
%type <std::shared_ptr<Verilogast::netreg_type>>    netreg_type
%type <std::shared_ptr<Verilogast::signedType>>    signed_opt
%type <std::shared_ptr<Verilogast::range>>    range_opt
%type <std::shared_ptr<Verilogast::range>>    range
%type <std::shared_ptr<Verilogast::expression>>    equ1_expression_opt

%type <std::shared_ptr<Verilogast::port_reference>>    port_reference
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::port_reference>>>>    comma_port_reference_list

%type <std::shared_ptr<Verilogast::range_expression>> lsquare_range_expression_rsquare_opt
%type <std::shared_ptr<Verilogast::range_expression>> lsquare_range_expression_rsquare
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::range_expression>>>> lsquare_range_expression_rsquare_list

%type <std::shared_ptr<Verilogast::inout_declaration>>   inout_declaration
%type <std::shared_ptr<Verilogast::input_declaration>>   input_declaration
%type <std::shared_ptr<Verilogast::output_declaration>>   output_declaration
%type <std::shared_ptr<Verilogast::port_declaration>>   port_declaration
%type <std::shared_ptr<Verilogast::net_declaration>>   net_declaration
%type <std::shared_ptr<Verilogast::reg_declaration>>   reg_declaration
%type <std::shared_ptr<Verilogast::integer_declaration>>   integer_declaration
%type <std::shared_ptr<Verilogast::real_declaration>>   real_declaration
%type <std::shared_ptr<Verilogast::time_declaration>>   time_declaration
%type <std::shared_ptr<Verilogast::realtime_declaration>>   realtime_declaration
%type <std::shared_ptr<Verilogast::event_declaration>>   event_declaration
%type <std::shared_ptr<Verilogast::genvar_declaration>>   genvar_declaration
%type <std::shared_ptr<Verilogast::task_declaration>>   task_declaration
%type <std::shared_ptr<Verilogast::function_declaration>>   function_declaration
%type <std::shared_ptr<Verilogast::local_parameter_declaration>>   local_parameter_declaration
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::defparam_assignment>>>>  parameter_override
%type <std::shared_ptr<Verilogast::continuous_assign>>  continuous_assign 
%type <std::shared_ptr<Verilogast::module_instantiation>>   module_instantiation
%type <std::shared_ptr<Verilogast::initial_construct>>   initial_construct
%type <std::shared_ptr<Verilogast::always_construct>>   always_construct
%type <std::shared_ptr<Verilogast::loop_generate_construct>>   loop_generate_construct
%type <std::shared_ptr<Verilogast::conditional_generate_construct>>   conditional_generate_construct

%type <std::shared_ptr<Verilogast::generate_region>>    generate_region
%type <std::shared_ptr<Verilogast::parameter_declaration>>    parameter_declaration

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::defparam_assignment>>>>  list_of_defparam_assignments
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::defparam_assignment>>>>  comma_defparam_assignment_list
%type <std::shared_ptr<Verilogast::defparam_assignment>>  defparam_assignment
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::param_assignment>>>>  list_of_param_assignments
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::param_assignment>>>>  comma_param_assignment_list
%type <std::shared_ptr<Verilogast::param_assignment>>  param_assignment

%type <std::shared_ptr<Verilogast::parameter_type>>    parameter_type
%type <std::shared_ptr<Verilogast::parameter_type>>    parameter_type_opt
%type <int> key_parameter_opt

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::real_type>>>>  list_of_real_identifiers
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::real_type>>>>  comma_real_type_list
%type <std::shared_ptr<Verilogast::real_type>>  real_type

%type <std::shared_ptr<Verilogast::net_type>>   net_type_opt
%type <std::shared_ptr<Verilogast::net_type>>   net_type


%type <std::shared_ptr<Verilogast::port_identifier_equ1_expression_opt>>   port_identifier_equ1_expression_opt
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::port_identifier_equ1_expression_opt>>>>   list_of_variable_port_identifiers
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::port_identifier_equ1_expression_opt>>>>   comma_port_identifier_equ1_expression_opt_list

%type <std::shared_ptr<Verilogast::output_variable_type>>    output_variable_type

%type <std::shared_ptr<Verilogast::event_identifier_dimension_list>>    event_identifier_dimension_list
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::event_identifier_dimension_list>>>>    list_of_event_identifiers
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::event_identifier_dimension_list>>>>    comma_event_identifier_dimension_list_list

%type <std::shared_ptr<Verilogast::variable_type>>    variable_type
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::variable_type>>>>    list_of_variable_identifiers
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::variable_type>>>>    comma_variable_type_list

%type <std::shared_ptr<Verilogast::drive_strength>>    drive_strength_opt
%type <std::shared_ptr<Verilogast::drive_strength>>    drive_strength

%type <std::shared_ptr<Verilogast::delay3>>    delay3_opt
%type <std::shared_ptr<Verilogast::delay3>>    delay3

%type <std::shared_ptr<Verilogast::vectored_scalared>>    vectored_scalared_opt

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::net_identifier_dimension_list>>>>    list_of_net_identifiers
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::net_identifier_dimension_list>>>>    comma_net_identifier_dimension_list_list
%type <std::shared_ptr<Verilogast::net_identifier_dimension_list>>    net_identifier_dimension_list

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::net_decl_assignment>>>>    list_of_net_decl_assignments
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::net_decl_assignment>>>>    comma_net_decl_assignment_list
%type <std::shared_ptr<Verilogast::net_decl_assignment>>    net_decl_assignment

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::dimension>>>>   dimension_list
%type <std::shared_ptr<Verilogast::dimension>>    dimension

%type <std::shared_ptr<Verilogast::expression>>    expression
%type <std::shared_ptr<Verilogast::expression>>    expression_opt
%type <std::shared_ptr<Verilogast::expression>>    dimension_expression
%type <std::shared_ptr<Verilogast::expression>>    ordered_parameter_assignment
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::expression>>>>    comma_ordered_parameter_assignment_list
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::expression>>>>    comma_expression_list
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::expression>>>>    lp_expression_opt_comma_expression_list_rp_opt
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::expression>>>>    lp_expression_comma_expression_list_rp_op
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::expression>>>>    lp_expression_opt_comma_expression_list_rp

%type <std::shared_ptr<Verilogast::strength>>    strength0
%type <std::shared_ptr<Verilogast::strength>>    strength1
%type <std::shared_ptr<Verilogast::delay_value>>    delay_value

%type <std::shared_ptr<Verilogast::mintypmax_expression>>    mintypmax_expression
%type <std::shared_ptr<Verilogast::mintypmax_expression>>    mintypmax_expression_opt

%type <std::shared_ptr<Verilogast::hierarchical_identifier>>    hierarchical_identifier
%type <std::shared_ptr<Verilogast::automatic>>    automatic_opt
%type <std::shared_ptr<Verilogast::function_range_or_type>>    function_range_or_type
%type <std::shared_ptr<Verilogast::function_item_declaration>>    function_item_declaration
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::function_item_declaration>>>>    function_item_declaration_list
%type <std::shared_ptr<Verilogast::statement>>    function_statement
%type <std::shared_ptr<Verilogast::statement>>    statement_or_null
%type <std::shared_ptr<Verilogast::statement>>    else_statement_or_null_opt
%type <std::shared_ptr<Verilogast::statement>>    statement

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::attribute_instance_list_tf_input_declaration>>>>    function_port_list
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::attribute_instance_list_tf_input_declaration>>>>    comma_attribute_instance_list_tf_input_declaration_list
%type <std::shared_ptr<Verilogast::attribute_instance_list_tf_input_declaration>>    attribute_instance_list_tf_input_declaration

%type <std::shared_ptr<Verilogast::tf_io_declaration_gen>>   tf_io_declaration_gen

%type <std::shared_ptr<Verilogast::block_item_declaration>>   block_item_declaration
%type <std::shared_ptr<Verilogast::tf_input_declaration>>   tf_input_declaration
%type <std::shared_ptr<Verilogast::tf_output_declaration>>   tf_output_declaration
%type <std::shared_ptr<Verilogast::tf_inout_declaration>>   tf_inout_declaration

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::task_port_item>>>>    task_port_list
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::task_port_item>>>>    comma_task_port_item_list
%type <std::shared_ptr<Verilogast::task_port_item>>    task_port_item

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::task_item_declaration>>>>    task_item_declaration_list
%type <std::shared_ptr<Verilogast::task_item_declaration>>    task_item_declaration

%type <std::shared_ptr<Verilogast::reg>>    reg_opt

%type <std::shared_ptr<Verilogast::task_port_type>>    task_port_type

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::block_variable_type>>>>    list_of_block_variable_identifiers
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::block_variable_type>>>>    comma_block_variable_type_list
%type <std::shared_ptr<Verilogast::block_variable_type>>    block_variable_type

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::block_real_type>>>>    list_of_block_real_identifiers
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::block_real_type>>>>    comma_block_real_type_list
%type <std::shared_ptr<Verilogast::block_real_type>>    block_real_type

%type <std::shared_ptr<Verilogast::parameter_value_assignment>>    parameter_value_assignment_opt
%type <std::shared_ptr<Verilogast::parameter_value_assignment>>    parameter_value_assignment
%type <std::shared_ptr<Verilogast::parameter_value_assignment>>    list_of_parameter_assignments

%type <std::shared_ptr<Verilogast::module_instance>>    module_instance
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::module_instance>>>>    comma_module_instance_list

%type <std::shared_ptr<Verilogast::named_parameter_assignment>>   named_parameter_assignment 
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::named_parameter_assignment>>>>   comma_named_parameter_assignment_list 

%type <std::shared_ptr<Verilogast::name_of_module_instance>>   name_of_module_instance
%type <std::shared_ptr<Verilogast::list_of_port_connections>>   list_of_port_connections
%type <std::shared_ptr<Verilogast::ordered_port_connection>>   ordered_port_connection
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::ordered_port_connection>>>>   comma_ordered_port_connection_list

%type <std::shared_ptr<Verilogast::named_port_connection>>   named_port_connection
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::named_port_connection>>>>   comma_named_port_connection_list

%type <std::shared_ptr<Verilogast::genvar_initialization>>   genvar_initialization
%type <std::shared_ptr<Verilogast::genvar_iteration>>   genvar_iteration
%type <std::shared_ptr<Verilogast::generate_block>>   generate_block
%type <std::shared_ptr<Verilogast::generate_block>>   generate_block_or_null
%type <std::shared_ptr<Verilogast::generate_block>>   else_generate_block_or_null_opt

%type <std::shared_ptr<Verilogast::if_generate_construct>>   if_generate_construct
%type <std::shared_ptr<Verilogast::case_generate_construct>>   case_generate_construct
%type <std::shared_ptr<Verilogast::case_generate_item>>   case_generate_item
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::case_generate_item>>>>   case_generate_item_list
%type <std::shared_ptr<Verilogast::colon_opt>>   colon_opt

%type <std::shared_ptr<Verilogast::net_assignment>>   net_assignment
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::net_assignment>>>>   list_of_net_assignments
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::net_assignment>>>>   comma_net_assignment_list

%type <std::shared_ptr<Verilogast::net_lvalue>>   net_lvalue
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::net_lvalue>>>>   comma_net_lvalue_list


%type <std::shared_ptr<Verilogast::delay_or_event_control>>   delay_or_event_control_opt
%type <std::shared_ptr<Verilogast::delay_or_event_control>>   delay_or_event_control

%type <std::shared_ptr<Verilogast::blocking_assignment>>   blocking_assignment
%type <std::shared_ptr<Verilogast::nonblocking_assignment>>   nonblocking_assignment

%type <std::shared_ptr<Verilogast::procedural_continuous_assignments>>   procedural_continuous_assignments

%type <std::shared_ptr<Verilogast::par_block>>   par_block
%type <std::shared_ptr<Verilogast::seq_block>>   seq_block
%type <std::shared_ptr<Verilogast::colon_block_identifier>>   colon_block_identifier_opt

%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::statement_or_block_item>>>>   statement_or_block_item_list
%type <std::shared_ptr<Verilogast::statement_or_block_item>>   statement_or_block_item

%type <std::shared_ptr<Verilogast::case_statement>>   case_statement
%type <std::shared_ptr<Verilogast::conditional_statement>>   conditional_statement
%type <std::shared_ptr<Verilogast::disable_statement>>   disable_statement
%type <std::shared_ptr<Verilogast::event_trigger>>   event_trigger
%type <std::shared_ptr<Verilogast::loop_statement>>   loop_statement
%type <std::shared_ptr<Verilogast::procedural_timing_control_statement>>   procedural_timing_control_statement
%type <std::shared_ptr<Verilogast::system_task_enable>>   system_task_enable
%type <std::shared_ptr<Verilogast::task_enable>>    task_enable
%type <std::shared_ptr<Verilogast::wait_statement>>    wait_statement
%type <std::shared_ptr<Verilogast::delay_control>>    delay_control
%type <std::shared_ptr<Verilogast::event_control>>    event_control
%type <std::shared_ptr<Verilogast::event_expression>>    event_expression
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::event_expression>>>>   event_expression_orcomma_list
%type <int> or_comma
%type <std::shared_ptr<Verilogast::procedural_timing_control>>    procedural_timing_control
%type <std::shared_ptr<Verilogast::case_item>>    case_item
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::case_item>>>>   case_item_list
%type <std::shared_ptr<Verilogast::system_function_identifier>>    system_function_identifier
%type <std::shared_ptr<Verilogast::concatenation>>    concatenation
%type <std::shared_ptr<Verilogast::multiple_concatenation>>    multiple_concatenation
%type <std::shared_ptr<Verilogast::function_call>>    function_call
%type <std::shared_ptr<Verilogast::system_function_call>>    system_function_call
%type <std::shared_ptr<Verilogast::expression>>    base_expression
%type <std::shared_ptr<Verilogast::conditional_expression>>    conditional_expression
%type <std::shared_ptr<Verilogast::primary>>    primary
%type <std::shared_ptr<Verilogast::expression>>    width_expression
%type <std::shared_ptr<Verilogast::number>>    number
%type <std::shared_ptr<Verilogast::string_typedef>>    string_typedef

%type <std::shared_ptr<Verilogast::attr_spec>>    attr_spec
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::attr_spec>>>>    comma_attr_spec_list

%type <std::shared_ptr<Verilogast::identifier_lsq_expression_rsq>>    identifier_lsq_expression_rsq_opt
%type <std::shared_ptr<std::list<std::shared_ptr<Verilogast::identifier_lsq_expression_rsq>>>>    identifier_lsq_expression_rsq_opt_list


%code top{
/* this "connects" the bison parser in the driver to the flex scanner class
 * object. it defines the yylex() function call to pull the next token from the
 * current lexer object of the driver context. */
#include<tuple>
#include<list>
#include<memory>
#include"variant_exp.h"
/*defiing the types of rules*/
using namespace std;
#include"asthelpper.h"
#include"verilogast.h"
}

%code {
using namespace Verilogast;
extern yy::verilog_parser::symbol_type yylex();
}
%%

%start source_text;


/*rules*/
/*A.1.2 Verilog source text*/
source_text : description_list {$$=$1;}
;

description_list : 
		{
			$$=SHR_LIST_SHR(Verilogast::description)(); 
		}
	|	description_list description  
		{
			auto p=$1;
			p->push_back($2);
			$$=p;
		}
;

description :
	module_declaration	{
		$$=SHR2(description,T_description__module_declaration,($1));
	}
/*	| udp_declaration		{T_description__udp_declaration($1)}
	| config_declaration	{T_description__config_declaration($1)}*/
;

module_declaration :
		attribute_instance_list 
		module_keyword 
		module_identifier 
		module_parameter_port_list_opt 
		list_of_ports 
		SEMICOLON 
		module_item_list
		KEY_ENDMODULE
		{
			$$=SHR2(module_declaration,T_module_declaration__1,($1,$3,$4,$5,$7));
		}
/*	| attribute_instance_list 
		module_keyword 
		module_identifier 
		module_parameter_port_list_opt
		list_of_io_declarations
		SEMICOLON 
		module_item_list
		KEY_ENDMODULE
		{	
				record_pos $8;
				T_module_declaration__2(
				$1,$3,$4,$5,$7)
		}*/
;

attribute_instance_list :
		{
			$$=SHR_LIST_SHR(attribute_instance)();
		}
	|  attribute_instance_list attribute_instance {
			auto p=$1;
			p->push_back($2);
			$$=p;
		}
;

module_parameter_port_list_opt :
	{
		$$=SHR_LIST_SHR(parameter_declaration_gen)();
	}
	| module_parameter_port_list {$$=$1;}
;

module_item_list :
		{
			$$=SHR_LIST_SHR(module_item)();
		}
	|  module_item_list module_item {
			auto p=$1;
			p->push_back($2);
			$$=p;
		}
;

module_keyword : 
		KEY_MODULE			{$$=0;}
	|	KEY_MACROMODULE	{$$=0;}
;
/*non_port_module_item_list :
	{[]}
	|  non_port_module_item_list non_port_module_item
		{$1@[$2]}
;
*/
/*A.1.3 Module parameters and ports*/
module_parameter_port_list :
	JING 
	LPARENT 
		parameter_declaration_gen comma_parameter_declaration_list
	RPARENT
	{
		auto p=$4;
		p->push_front($3);
		$$=p;
	}
;

comma_parameter_declaration_list :
		{
			$$=SHR_LIST_SHR(parameter_declaration_gen)();
		}
	| comma_parameter_declaration_list COMMA parameter_declaration_gen 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

list_of_ports : 
	LPARENT 
		port comma_port_list
	RPARENT
		{
			auto p=$3;
			p->push_front($2);
			$$=p;
		}
;

comma_port_list :
		{
			$$=SHR_LIST_SHR(port)();
		}
	| comma_port_list COMMA port 
	{
		auto p=$1;
		p->push_back($3);
		$$=p;
	}
;

/*list_of_io_declarations :
	LPARENT 
		io_declaration comma_io_declaration_list
	RPARENT
		{
			record_pos $4;
			$2::$3
		}*/
/*can not be empty, orelse will conflict with empty list_of_ports*/
/*	| LPARENT RPARENT
		{[]}*/
/*;*/


/*comma_io_declaration_list :
	{[]}
	| comma_io_declaration_list COMMA io_declaration 
		{
			record_pos $2;
			$1@[$3]
		}
;
*/
port :
	/*port_expression_opt {T_port_position($1)}*/ /*merged ti last case*/
	PERIOD  port_identifier LPARENT port_expression_opt RPARENT
		{
//			$$=make_shared<port>(make_shared<T_port_exp>($2,$4));
			$$=SHR2(port,T_port_exp,($2,$4));
		}
	| io_type netreg_type signed_opt range_opt port_expression_opt equ1_expression_opt
		{
			$$=SHR2(port,T_port_net,($1,$2,$3,$4,$5,$6));
		}
;

port_expression_opt :
	{
		auto p = SHR_LIST_SHR(port_reference)(); 
		$$=SHR2(port_expression,T_port_expression,(p));
	}
	| port_expression {$$=$1;}
;

port_expression :
	port_reference	{
			auto p=SHR_LIST_SHR(port_reference)(); 
			p->push_back($1);
			$$=SHR2(port_expression,T_port_expression,(p));
		}
	| LBRACE port_reference comma_port_reference_list RBRACE
		{
			auto p=$3;
			p->push_front($2);
			$$=SHR2(port_expression,T_port_expression,(p));
		}
;

comma_port_reference_list :
		{
			$$=SHR_LIST_SHR(port_reference)(); 
		}
	| comma_port_reference_list COMMA port_reference  
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

port_reference :
	port_identifier lsquare_range_expression_rsquare_opt
		{$$=SHR2(port_reference,T_port_reference,($1,$2));}
;

lsquare_range_expression_rsquare_opt :
	{$$=SHR2(range_expression,T_range_expression_NOSPEC,());}
	| lsquare_range_expression_rsquare {$$=$1;}
;

/*
lsquare_range_expression_rsquare :
	LSQUARE
		range_expression
	RSQUARE
		{
			record_pos $3;
			$2
		}
;*/

port_declaration :
	attribute_instance_list inout_declaration 
		{$$=SHR2(port_declaration,T_port_declaration__inout_declaration,($1,$2));}
	| attribute_instance_list input_declaration
		{$$=SHR2(port_declaration,T_port_declaration__input_declaration,($1,$2));}
	| attribute_instance_list output_declaration
		{$$=SHR2(port_declaration,T_port_declaration__output_declaration,($1,$2));}
;

/*A.1.4 Module items*/
module_item :
	port_declaration SEMICOLON {
		$$=SHR3(module_item,module_item1,T_module_item__port_declaration,($1));
	}
	| non_port_module_item {$$=$1;}
;

non_port_module_item :
	module_or_generate_item {$$=$1;}
	| generate_region {
		$$=SHR3(module_item,module_item1,T_module_item__generate_region,($1));}
/*	| specify_block {
		T_module_item__specify_block($1)}*/
	| attribute_instance_list parameter_declaration SEMICOLON {
		$$=SHR3(module_item,module_item1,T_module_item__parameter_declaration,($1,$2));}
/*	| attribute_instance_list specparam_declaration {
		T_module_item__specparam_declaration($1,$2)}*/
;

module_or_generate_item :
	attribute_instance_list net_declaration      {
		$$=SHR3(module_item,module_item1,T_module_item__net_declaration,($1,$2));}
|	attribute_instance_list reg_declaration      {
		$$=SHR3(module_item,module_item1,T_module_item__reg_declaration,($1,$2));}
|	attribute_instance_list integer_declaration  {
		$$=SHR3(module_item,module_item1,T_module_item__integer_declaration,($1,$2));}
|	attribute_instance_list real_declaration     {
		$$=SHR3(module_item,module_item1,T_module_item__real_declaration,($1,$2));}
|	attribute_instance_list time_declaration     {
		$$=SHR3(module_item,module_item1,T_module_item__time_declaration,($1,$2));}
|	attribute_instance_list realtime_declaration {
		$$=SHR3(module_item,module_item1,T_module_item__realtime_declaration,($1,$2));}
|	attribute_instance_list event_declaration    {
		$$=SHR3(module_item,module_item1,T_module_item__event_declaration,($1,$2));}
|	attribute_instance_list genvar_declaration   {
		$$=SHR3(module_item,module_item2,T_module_item__genvar_declaration,($1,$2));}
|	attribute_instance_list task_declaration     {
		$$=SHR3(module_item,module_item2,T_module_item__task_declaration,($1,$2));}
|	attribute_instance_list function_declaration {
		$$=SHR3(module_item,module_item2,T_module_item__function_declaration,($1,$2));}
| attribute_instance_list local_parameter_declaration SEMICOLON {
		$$=SHR3(module_item,module_item2,T_module_item__local_parameter_declaration,($1,$2));}
| attribute_instance_list parameter_override {
		$$=SHR3(module_item,module_item2,T_module_item__parameter_override,($1,$2));}
| attribute_instance_list continuous_assign {
		$$=SHR3(module_item,module_item2,T_module_item__continuous_assign,($1,$2));}
/*| attribute_instance_list gate_instantiation {
		T_module_item__gate_instantiation($1,$2)}
| attribute_instance_list udp_instantiation {
		T_module_item__udp_instantiation($1,$2)}*/
| attribute_instance_list module_instantiation {
		$$=SHR3(module_item,module_item2,T_module_item__module_instantiation,($1,$2));}
| attribute_instance_list initial_construct {
		$$=SHR3(module_item,module_item2,T_module_item__initial_construct,($1,$2));}
| attribute_instance_list always_construct {
		$$=SHR3(module_item,module_item2,T_module_item__always_construct,($1,$2));}
| attribute_instance_list loop_generate_construct {
		$$=SHR3(module_item,module_item2,T_module_item__loop_generate_construct,($1,$2));}
| attribute_instance_list conditional_generate_construct {
		$$=SHR3(module_item,module_item2,T_module_item__conditional_generate_construct,($1,$2));}
;

parameter_override :
	KEY_DEFPARAM list_of_defparam_assignments SEMICOLON
	 { $$=$2; }
;

/*A.1.5 Configuration source text*/
/*config_declaration :
	KEY_CONFIG config_identifier SEMICOLON
	design_statement
	config_rule_statement_list
	KEY_ENDCONFIG
	{
		record_pos $6;
		T_config_declaration($2,$4,$5)
	}
;


config_rule_statement_list :
	{[]}
	| config_rule_statement_list config_rule_statement 
		{$1@[$2]}
;

design_statement : 
	KEY_DESIGN 
		library_identifier_period_opt_cell_identifier_list
	SEMICOLON
		{
			record_pos $3;
			T_design_statement($2)
		}
;

library_identifier_period_opt_cell_identifier_list :
	{[]}
	| library_identifier_period_opt_cell_identifier_list library_identifier_period_opt_cell_identifier  
		{$1@[$2]}
;

library_identifier_period_opt_cell_identifier :
	library_identifier_period_opt cell_identifier
	{T_lib_cell_identifier($1,$2)}
;

library_identifier_period_opt :
	{T_identifier_NOSPEC}
	| library_identifier PERIOD {
			record_pos $2;
			$1
		}
;

config_rule_statement :
	KEY_DEFAULT liblist_clause SEMICOLON {
			record_pos $3;
			T_config_rule_statement__default($2)}
	| inst_clause liblist_clause SEMICOLON {
			record_pos $3;
			T_config_rule_statement__inst_lib($1,$2)}
	| inst_clause use_clause SEMICOLON	{
			record_pos $3;
			T_config_rule_statement__inst_use($1,$2)}
	| cell_clause liblist_clause SEMICOLON	{
			record_pos $3;
			T_config_rule_statement__cell_lib($1,$2)}
	| cell_clause use_clause SEMICOLON	{
			record_pos $3;
			T_config_rule_statement__cell_use($1,$2)}
;

inst_clause : 
	KEY_INSTANCE inst_name {
		record_pos $1;
		$2
	}
;

inst_name : 
	topmodule_identifier comma_instance_identifier_list
	{$1::$2}
;

comma_instance_identifier_list :
	{[]}
	| comma_instance_identifier_list COMMA instance_identifier 
	{
		record_pos $2;
		$1@[$3]
	}
;

cell_clause :
	KEY_CELL library_identifier_period_opt_cell_identifier {
		record_pos $1;
		$2
	}
;

liblist_clause :
	KEY_LIBLIST library_identifier_list {
		record_pos $1;
		$2
	}
;

library_identifier_list :
	{[]}
	| library_identifier_list library_identifier  {$1@[$2]}
;

use_clause :
	KEY_USE library_identifier_period_opt_cell_identifier colon_config_opt
		{
			record_pos $1;
			T_use_clause($2,$3)
		}
;

colon_config_opt :
	{T_colon_config_opt_FALSE}
	| COLON KEY_CONFIG  {
			record_pos $2;
			T_colon_config_opt_TRUE
		}
;
*/
/*A.2 Declarations
A.2.1 Declaration types
A.2.1.1 Module parameter declarations*/

local_parameter_declaration :
	KEY_LOCALPARAM signed_opt range_opt list_of_param_assignments
		{
			$$=SHR2(local_parameter_declaration,T_local_parameter_declaration_1,($2,$3,$4));
		}
	| KEY_LOCALPARAM parameter_type list_of_param_assignments
		{
			$$=SHR2(local_parameter_declaration,T_local_parameter_declaration_2,($2,$3));
		}
;

signed_opt :
	{$$=SHR2(signedType,T_signed_FALSE,());}
	| KEY_SIGNED {
			$$=SHR2(signedType,T_signed_TRUE,());
		}
;

range_opt :
	{$$=SHR2(range,T_range_NOSPEC,());}
	| range {$$=$1;}
;

parameter_declaration :
	KEY_PARAMETER signed_opt range_opt list_of_param_assignments
		{
			$$=SHR2(parameter_declaration,T_parameter_declaration_1,($2,$3,$4));
		}
	| KEY_PARAMETER parameter_type list_of_param_assignments
		{
			$$=SHR2(parameter_declaration,T_parameter_declaration_2,($2,$3));
		}
;


/*genarized to avoid conflict*/
parameter_declaration_gen :
	key_parameter_opt parameter_type_opt signed_opt range_opt param_assignment
		{
			$$=SHR2(parameter_declaration_gen,T_parameter_declaration_gen_1,($2,$3,$4,$5));
		}
;

key_parameter_opt :
	{$$=0;}
	| KEY_PARAMETER {$$=0;}
;

/*specparam_declaration :
	KEY_SPECPARAM range_opt list_of_specparam_assignments SEMICOLON
		{
			record_pos $4;
			T_specparam_declaration($2,$3)
		}
;
*/
parameter_type_opt :
	{$$=SHR2(parameter_type,T_parameter_type__NOSPEC,());}
	| parameter_type {$$=$1;}
;

parameter_type :
	KEY_INTEGER    {$$=SHR2(parameter_type,T_parameter_type__INTEGER,());}
	| KEY_REAL 	   {$$=SHR2(parameter_type,T_parameter_type__REAL,());}
	| KEY_REALTIME {$$=SHR2(parameter_type,T_parameter_type__REALTIME,());}
	| KEY_TIME	   {$$=SHR2(parameter_type,T_parameter_type__TIME,());}
;

/*A.2.1.2 Port declarations*/
inout_declaration :
	KEY_INOUT net_type_opt signed_opt range_opt list_of_port_identifiers
		{$$=SHR2(inout_declaration,T_inout_declaration,($2,$3,$4,$5));}
;

net_type_opt :
	{$$=SHR2(net_type,T_net_type_NOSPEC,());}
	| net_type {$$=$1;}
;

input_declaration :
	KEY_INPUT net_type_opt signed_opt  range_opt list_of_port_identifiers
		{$$=SHR2(input_declaration,T_input_declaration,($2,$3,$4,$5));}
;

output_declaration :
	KEY_OUTPUT net_type_opt signed_opt range_opt list_of_port_identifiers
		{$$=SHR2(output_declaration,T_output_declaration_net,($2,$3,$4,$5));}
	| KEY_OUTPUT KEY_REG signed_opt range_opt list_of_variable_port_identifiers
		{$$=SHR2(output_declaration,T_output_declaration_reg,($3,$4,$5));}
	| KEY_OUTPUT output_variable_type list_of_variable_port_identifiers
		{$$=SHR2(output_declaration,T_output_declaration_var,($2,$3));}
;		


/*io_declaration :
	io_type netreg_type signed_opt range_opt port_identifier_equ1_expression_opt
		{T_io_declaration_net($1,$2,$3,$4,$5)}
;*/

netreg_type :
	{$$=SHR2(netreg_type,T_netreg_type__NOSPEC,());}
	| KEY_SUPPLY0 	  {$$=SHR2(netreg_type,T_netreg_type__KEY_SUPPLY0,());}
	| KEY_SUPPLY1	    {$$=SHR2(netreg_type,T_netreg_type__KEY_SUPPLY1,());}
	| KEY_TRI			    {$$=SHR2(netreg_type,T_netreg_type__KEY_TRI,());}
	| KEY_TRIAND 	    {$$=SHR2(netreg_type,T_netreg_type__KEY_TRIAND,());}
	| KEY_TRIOR 			{$$=SHR2(netreg_type,T_netreg_type__KEY_TRIOR,());}
	| KEY_TRI0 				{$$=SHR2(netreg_type,T_netreg_type__KEY_TRI0,());}
	| KEY_TRI1				{$$=SHR2(netreg_type,T_netreg_type__KEY_TRI1,());}
	| KEY_UWIRE 			{$$=SHR2(netreg_type,T_netreg_type__KEY_UWIRE,());}
	| KEY_WIRE 				{$$=SHR2(netreg_type,T_netreg_type__KEY_WIRE,());}
	| KEY_WAND 				{$$=SHR2(netreg_type,T_netreg_type__KEY_WAND,());}
	| KEY_WOR					{$$=SHR2(netreg_type,T_netreg_type__KEY_WOR,());}
	| KEY_REG					{$$=SHR2(netreg_type,T_netreg_type__KEY_REG,());}
	| KEY_INTEGER			{$$=SHR2(netreg_type,T_netreg_type__KEY_INTEGER,());}
	| KEY_TIME				{$$=SHR2(netreg_type,T_netreg_type__KEY_TIME,());}
;

io_type :
	{$$=SHR2(io_type,T_io_type_NOSPEC,());}
	| KEY_OUTPUT	{$$=SHR2(io_type,T_io_type_output,());}
	| KEY_INPUT		{$$=SHR2(io_type,T_io_type_input,());}
	| KEY_INOUT		{$$=SHR2(io_type,T_io_type_inout,());}

/*A.2.1.3 Type declarations*/
event_declaration :
	KEY_EVENT list_of_event_identifiers SEMICOLON
		{$$=SHR2(event_declaration,T_event_declaration,($2));}
;

integer_declaration :
	KEY_INTEGER list_of_variable_identifiers SEMICOLON
		{$$=SHR2(integer_declaration,T_integer_declaration,($2));}
;

net_declaration :
	net_type drive_strength_opt vectored_scalared_opt signed_opt range_opt delay3_opt list_of_net_identifiers SEMICOLON
		{$$=SHR2(net_declaration,T_net_declaration_net_type3,($1,$2,$3,$4,$5,$6,$7));}
	| net_type drive_strength_opt vectored_scalared_opt signed_opt range_opt delay3_opt list_of_net_decl_assignments SEMICOLON
		{$$=SHR2(net_declaration,T_net_declaration_net_type4,($1,$2,$3,$4,$5,$6,$7));}
/*	| KEY_TRIREG charge_strength_opt signed_opt delay3_opt list_of_net_identifiers SEMICOLON
		{T_net_declaration_trireg_1($2,$3,$4,$5)}
	| KEY_TRIREG drive_strength_opt signed_opt delay3_opt list_of_net_decl_assignments SEMICOLON
		{T_net_declaration_trireg_2($2,$3,$4,$5)}
	| KEY_TRIREG charge_strength_opt vectored_scalared_opt signed_opt range delay3_opt list_of_net_identifiers SEMICOLON
		{T_net_declaration_trireg_3($2,$3,$4,$5,$6)}
	| KEY_TRIREG drive_strength_opt vectored_scalared_opt signed_opt range delay3_opt list_of_net_decl_assignments SEMICOLON
		{T_net_declaration_trireg_4($2,$3,$4,$5,$6,$7)}*/
;

/*charge_strength_opt :
	{T_charge_strength_NOSPEC}
	| charge_strength {$1}
;
*/
delay3_opt :
	{$$=SHR2(delay3,T_delay3_NOSPEC,());}
	| delay3 {$$=$1;}
;

vectored_scalared_opt :
	{$$=SHR2(vectored_scalared,T_vectored_scalared_NOSPEC,());}
	| KEY_VECTORED {$$=SHR2(vectored_scalared,T_vectored_scalared_vectored,());}
	| KEY_SCALARED {$$=SHR2(vectored_scalared,T_vectored_scalared_scalared,());}
;

drive_strength_opt :
	{$$=SHR2(drive_strength,T_drive_strength_NOSPEC,());}
	| drive_strength {$$=$1;}
;

real_declaration :
	KEY_REAL list_of_real_identifiers SEMICOLON
		{$$=SHR2(real_declaration,T_real_declaration,($2));}
;

realtime_declaration :
	KEY_REALTIME list_of_real_identifiers SEMICOLON
		{$$=SHR2(realtime_declaration,T_realtime_declaration,($2));}
;

reg_declaration : 
	KEY_REG signed_opt range_opt list_of_variable_identifiers SEMICOLON
		{$$=SHR2(reg_declaration,T_reg_declaration,($2,$3,$4));}
;

time_declaration :
	KEY_TIME list_of_variable_identifiers SEMICOLON
		{$$=SHR2(time_declaration,T_time_declaration,($2));}
;

/*A.2.2 Declaration data types
A.2.2.1 Net and variable types*/
net_type :
	KEY_SUPPLY0 	    {$$=SHR2(net_type,T_net_type__KEY_SUPPLY0,());}
	| KEY_SUPPLY1	    {$$=SHR2(net_type,T_net_type__KEY_SUPPLY1,());}
	| KEY_TRI			    {$$=SHR2(net_type,T_net_type__KEY_TRI,());}
	| KEY_TRIAND 	    {$$=SHR2(net_type,T_net_type__KEY_TRIAND,());}
	| KEY_TRIOR 			{$$=SHR2(net_type,T_net_type__KEY_TRIOR,());}
	| KEY_TRI0 				{$$=SHR2(net_type,T_net_type__KEY_TRI0,());}
	| KEY_TRI1				{$$=SHR2(net_type,T_net_type__KEY_TRI1,());}
	| KEY_UWIRE 			{$$=SHR2(net_type,T_net_type__KEY_UWIRE,());}
	| KEY_WIRE 				{$$=SHR2(net_type,T_net_type__KEY_WIRE,());}
	| KEY_WAND 				{$$=SHR2(net_type,T_net_type__KEY_WAND,());}
	| KEY_WOR					{$$=SHR2(net_type,T_net_type__KEY_WOR,());}
;

output_variable_type :
	KEY_INTEGER {$$=SHR2(output_variable_type,T_output_variable_type_INTEGER,());}
	| KEY_TIME  {$$=SHR2(output_variable_type,T_output_variable_type_TIME,());}
;

real_type :
	real_identifier dimension_list
		{$$=SHR2(real_type,T_real_type_noass,($1,$2));}
	| real_identifier EQU1 expression
		{$$=SHR2(real_type,T_real_type_ass,($1,$3));}
;

dimension_list :
		{
			$$=SHR_LIST_SHR(dimension)();
		}
	| dimension_list dimension 
		{
			auto p=$1;
			p->push_back($2);
			$$=p;
		}
;

variable_type :
	variable_identifier dimension_list
		{$$=SHR2(variable_type,T_variable_type_noass,($1,$2));}
	| variable_identifier EQU1 expression
		{$$=SHR2(variable_type,T_variable_type_ass,($1,$3));}
;

/*A.2.2.2 Strengths*/

drive_strength :
	LPARENT strength0 COMMA strength1 RPARENT
		{$$=SHR2(drive_strength,T_drive_strength,($2,$4));}
	| LPARENT strength1 COMMA strength0 RPARENT
		{$$=SHR2(drive_strength,T_drive_strength,($2,$4));}
	| LPARENT strength0 COMMA KEY_HIGHZ1 RPARENT
		{$$=SHR2(drive_strength,T_drive_strength,($2,SHR2(strength,KEY_HIGHZ1,())));}
	| LPARENT strength1 COMMA KEY_HIGHZ0 RPARENT
		{$$=SHR2(drive_strength,T_drive_strength,($2,SHR2(strength,KEY_HIGHZ0,())));}
	| LPARENT KEY_HIGHZ0 COMMA strength1 RPARENT
		{$$=SHR2(drive_strength,T_drive_strength,(SHR2(strength,KEY_HIGHZ0,()),$4));}
	| LPARENT KEY_HIGHZ1 COMMA strength0 RPARENT
		{$$=SHR2(drive_strength,T_drive_strength,(SHR2(strength,KEY_HIGHZ1,()),$4));}
;



strength0 :
	KEY_SUPPLY0		  {$$=SHR2(strength,KEY_SUPPLY0,());}
	| KEY_STRONG0		{$$=SHR2(strength,KEY_STRONG0,());}
	| KEY_PULL0			{$$=SHR2(strength,KEY_PULL0,());}
	| KEY_WEAK0     {$$=SHR2(strength,KEY_WEAK0,());}
;
strength1 :
	KEY_SUPPLY1		  {$$=SHR2(strength,KEY_SUPPLY1,());}
	| KEY_STRONG1		{$$=SHR2(strength,KEY_STRONG1,());}
	| KEY_PULL1			{$$=SHR2(strength,KEY_PULL1,());}
	| KEY_WEAK1     {$$=SHR2(strength,KEY_WEAK1,());}
;

/*charge_strength : 
	LPARENT KEY_SMALL RPARENT    {$$=SHR2(,T_charge_strength__small,();}
	| LPARENT KEY_MEDIUM RPARENT {$$=SHR2(,T_charge_strength__medium,();}
	| LPARENT KEY_LARGE RPARENT  {$$=SHR2(,T_charge_strength__large,();}
;
*/
/*A.2.2.3 Delays*/

delay3 :
	JING delay_value
		{$$=SHR2(delay3,T_delay3_1,($2));}
	| JING LPARENT mintypmax_expression  RPARENT
		{$$=SHR2(delay3,T_delay3_minmax1,($3));}
	| JING LPARENT mintypmax_expression  COMMA mintypmax_expression RPARENT
		{$$=SHR2(delay3,T_delay3_minmax2,($3,$5));}
	| JING LPARENT mintypmax_expression  COMMA mintypmax_expression COMMA mintypmax_expression  RPARENT
		{$$=SHR2(delay3,T_delay3_minmax3,($3,$5,$7));}
;


/*delay2 :
	JING delay_value
		{$$=SHR2(,T_delay2_1,($2);}
	| JING LPARENT mintypmax_expression RPARENT
		{$$=SHR2(,T_delay2_minmax1,($3);}
	| JING LPARENT mintypmax_expression COMMA mintypmax_expression  RPARENT
		{$$=SHR2(,T_delay2_minmax2,($3,$5);}
;

*/
delay_value :
	UNSIGNED_NUMBER {$$=SHR2(delay_value,T_delay_value_UNSIGNED_NUMBER,($1));}
	| REAL_NUMBER   {$$=SHR2(delay_value,T_delay_value_REAL_NUMBER,($1));}
	| identifier    {$$=SHR2(delay_value,T_delay_value_id,($1));}
;

/*A.2.3 Declaration lists*/
list_of_defparam_assignments :
	defparam_assignment comma_defparam_assignment_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;


comma_defparam_assignment_list :
		{
			$$=SHR_LIST_SHR(defparam_assignment)();
		}
	|comma_defparam_assignment_list COMMA defparam_assignment 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

list_of_event_identifiers :
	event_identifier_dimension_list comma_event_identifier_dimension_list_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

comma_event_identifier_dimension_list_list :
		{
			$$=SHR_LIST_SHR(event_identifier_dimension_list)();
		}
	| comma_event_identifier_dimension_list_list COMMA event_identifier_dimension_list 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

event_identifier_dimension_list :
	event_identifier dimension_list
		{$$=SHR2(event_identifier_dimension_list,T_event_identifier_dimension_list,($1,$2));}
;

list_of_net_decl_assignments :
	net_decl_assignment comma_net_decl_assignment_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

comma_net_decl_assignment_list :
		{
			$$=SHR_LIST_SHR(net_decl_assignment)();
		}
	| comma_net_decl_assignment_list COMMA net_decl_assignment 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

list_of_net_identifiers :
	net_identifier_dimension_list
	comma_net_identifier_dimension_list_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

net_identifier_dimension_list :
	net_identifier dimension_list
		{$$=SHR2(net_identifier_dimension_list,T_net_identifier_dimension_list,($1,$2));}
;

comma_net_identifier_dimension_list_list:
		{
			$$=SHR_LIST_SHR(net_identifier_dimension_list)();
		}
	| comma_net_identifier_dimension_list_list COMMA net_identifier_dimension_list 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

list_of_param_assignments :
	param_assignment comma_param_assignment_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

comma_param_assignment_list :
		{
			$$=SHR_LIST_SHR(param_assignment)(); 
		}
	| comma_param_assignment_list COMMA param_assignment 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

list_of_port_identifiers :
	port_identifier comma_port_identifier_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

comma_port_identifier_list :
		{
			$$=SHR_LIST_SHR(identifier)();
		}
	| comma_port_identifier_list COMMA port_identifier 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

list_of_real_identifiers :
	real_type comma_real_type_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

comma_real_type_list :
		{
			$$=SHR_LIST_SHR(real_type)();
		}
	| comma_real_type_list COMMA real_type 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

/*list_of_specparam_assignments :
	specparam_assignment comma_specparam_assignment_list
		{$1::$2}
;

comma_specparam_assignment_list :
	{[]}
	| comma_specparam_assignment_list COMMA specparam_assignment 
		{$1@[$3]}
;
*/
list_of_variable_identifiers :
	variable_type comma_variable_type_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

comma_variable_type_list :
		{
			$$=SHR_LIST_SHR(variable_type)();
		}
	| comma_variable_type_list COMMA variable_type 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

list_of_variable_port_identifiers :
	port_identifier_equ1_expression_opt comma_port_identifier_equ1_expression_opt_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

port_identifier_equ1_expression_opt :
	port_identifier equ1_expression_opt
		{$$=SHR2(port_identifier_equ1_expression_opt,T_port_identifier_equ1_expression_opt,($1,$2));}
;

equ1_expression_opt :
	{$$=SHR2(expression,T_expression_NOSPEC,());}
	| EQU1 expression {$$=$2;}
;

comma_port_identifier_equ1_expression_opt_list :
		{
			$$=SHR_LIST_SHR(port_identifier_equ1_expression_opt)();
		}
	| comma_port_identifier_equ1_expression_opt_list COMMA port_identifier_equ1_expression_opt 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

/*A.2.4 Declaration assignments*/
defparam_assignment :
	hierarchical_identifier EQU1 mintypmax_expression
		{$$=SHR2(defparam_assignment,T_defparam_assignment,($1,$3));}
;

net_decl_assignment :
	net_identifier EQU1 expression
		{$$=SHR2(net_decl_assignment,T_net_decl_assignment,($1,$3));}
;

param_assignment :
	parameter_identifier EQU1 mintypmax_expression
		{$$=SHR2(param_assignment,T_param_assignment,($1,$3));}
;

/*specparam_assignment :
	specparam_identifier EQU1 mintypmax_expression
		{$$=SHR2(,T_specparam_assignment,($1,$3);}
	| pulse_control_specparam
		{$$=$1;}
;


pulse_control_specparam :
	KEY_PATHPULSE EQU1 LPARENT reject_limit_value comma_error_limit_value_opt RPARENT
		{$$=SHR2(,T_specparam_assignment_pulse1,($4,$5));}
	| KEY_PATHPULSE specify_input_terminal_descriptor DOLLOR specify_output_terminal_descriptor EQU1 LPARENT reject_limit_value comma_error_limit_value_opt RPARENT
		{$$=SHR2(,T_specparam_assignment_pulse2,($2,$4,$7,$8));}
;
comma_error_limit_value_opt :
	{$$=SHR2(,T_mintypmax_expression_NOSPEC,());}
	| COMMA error_limit_value {$$=$2;}
;	

error_limit_value : 
	limit_value
	{$$=$1;}
;

reject_limit_value :
	limit_value
		{$$=$1;}
;

limit_value : 
	mintypmax_expression
		{$$=$1;}
;

*/

/*A.2.5 Declaration ranges*/
dimension :
	LSQUARE	dimension_expression COLON dimension_expression RSQUARE
		{$$=SHR2(dimension,T_dimension,($2,$4));}
;

range :
	LSQUARE expression COLON expression RSQUARE
		{$$=SHR2(range,T_range,($2,$4));}
;


/*A.2.6 Function declarations*/
function_declaration :
	KEY_FUNCTION automatic_opt function_range_or_type function_identifier SEMICOLON
	function_item_declaration function_item_declaration_list
	function_statement
	KEY_ENDFUNCTION
		{
			auto p=$7;
			p->push_front($6);
			$$=SHR2(function_declaration,T_function_declaration_1,($2,$3,$4,p,$8));
		}	
| KEY_FUNCTION automatic_opt function_range_or_type function_identifier LPARENT function_port_list RPARENT SEMICOLON
	 /*block_item_declaration_list*/ /*replaced with function_item_declaration_list*/
	 function_item_declaration_list
	function_statement
	KEY_ENDFUNCTION
		{$$=SHR2(function_declaration,T_function_declaration_2,($2,$3,$4,$6,$9,$10));}
;


function_item_declaration_list :
		{
			$$=SHR_LIST_SHR(function_item_declaration)();
		}
	|  function_item_declaration_list function_item_declaration
		{
			auto p=$1;
			p->push_back($2);
			$$=p;
		}
;

automatic_opt :
	{$$=SHR2(automatic,T_automatic_false,());}
	| KEY_AUTOMATIC {$$=SHR2(automatic,T_automatic_true,());}
;

function_item_declaration :
	block_item_declaration
		{$$=SHR2(function_item_declaration,T_function_item_declaration_block,($1));}
	| attribute_instance_list tf_input_declaration SEMICOLON
		{$$=SHR2(function_item_declaration,T_function_item_declaration_input,($1,$2));}
;

function_port_list :
	attribute_instance_list_tf_input_declaration 
	comma_attribute_instance_list_tf_input_declaration_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

attribute_instance_list_tf_input_declaration :
	attribute_instance_list tf_io_declaration_gen
		{$$=SHR2(attribute_instance_list_tf_input_declaration,T_attribute_instance_list_tf_input_declaration,($1,$2));}
;

comma_attribute_instance_list_tf_input_declaration_list :
		{
			$$=SHR_LIST_SHR(attribute_instance_list_tf_input_declaration)();
		}
	| comma_attribute_instance_list_tf_input_declaration_list COMMA attribute_instance_list_tf_input_declaration 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

function_range_or_type :
	                   {$$=SHR2(function_range_or_type,T_function_range_or_type_NOSPEC,());}
	|	KEY_SIGNED       {$$=SHR2(function_range_or_type,T_function_range_or_type,(SHR2(signedType,T_signed_TRUE ,()),SHR2(range,T_range_NOSPEC,())));}
	| range				     {$$=SHR2(function_range_or_type,T_function_range_or_type,(SHR2(signedType,T_signed_FALSE,()),$1));}
	|	KEY_SIGNED range {$$=SHR2(function_range_or_type,T_function_range_or_type,(SHR2(signedType,T_signed_TRUE ,()),$2));}
	| KEY_INTEGER      {$$=SHR2(function_range_or_type,T_function_range_or_type_INTEGER,());}
	| KEY_REAL				 {$$=SHR2(function_range_or_type,T_function_range_or_type_REAL,());}
	| KEY_REALTIME		 {$$=SHR2(function_range_or_type,T_function_range_or_type_REALTIME,());}
	| KEY_TIME				 {$$=SHR2(function_range_or_type,T_function_range_or_type_TIME,());}
;

/*A.2.7 Task declarations*/

task_declaration :
	KEY_TASK automatic_opt task_identifier SEMICOLON
		task_item_declaration_list
		statement_or_null
		KEY_ENDTASK
		{$$=SHR2(task_declaration,T_task_declaration1,($2,$3,$5,$6));}
	| KEY_TASK automatic_opt task_identifier LPARENT task_port_list  RPARENT SEMICOLON
		/*block_item_declaration_list*/ /*replaced with task_item_declaration_list*/
		task_item_declaration_list
		statement_or_null
		KEY_ENDTASK
		{$$=SHR2(task_declaration,T_task_declaration2,($2,$3,$5,$8,$9));}
;

task_item_declaration_list :
		{
			$$=SHR_LIST_SHR(task_item_declaration)();
		}
	| task_item_declaration_list task_item_declaration 
		{
			auto p=$1;
			p->push_back($2);
			$$=p;
		}
;

/*block_item_declaration_list :
	{[]}
	| block_item_declaration_list block_item_declaration 
		{$1@[$2]}
;
*/
task_item_declaration :
	block_item_declaration
		{$$=SHR2(task_item_declaration,T_task_item_declaration_block,($1));}
	|  attribute_instance_list  tf_input_declaration SEMICOLON  {$$=SHR2(task_item_declaration,T_task_item_declaration_input,($1,$2));}
	|  attribute_instance_list  tf_output_declaration SEMICOLON {$$=SHR2(task_item_declaration,T_task_item_declaration_output,($1,$2));}
	|  attribute_instance_list  tf_inout_declaration SEMICOLON  {$$=SHR2(task_item_declaration,T_task_item_declaration_inout,($1,$2));}
;

task_port_list :
	task_port_item comma_task_port_item_list
		{
			$$=SHR_LIST_SHR(task_port_item)();
		}
;

comma_task_port_item_list :
		{
			$$=SHR_LIST_SHR(task_port_item)();
		}
	| comma_task_port_item_list COMMA task_port_item 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

task_port_item :
		 attribute_instance_list tf_io_declaration_gen
		 	{$$=SHR2(task_port_item,T_task_port_item_input,($1,$2));}
;


tf_input_declaration :
	KEY_INPUT reg_opt signed_opt range_opt list_of_port_identifiers
		{$$=SHR2(tf_input_declaration,T_tf_input_declaration_reg,($2,$3,$4,$5));}
	| KEY_INPUT task_port_type list_of_port_identifiers
		{$$=SHR2(tf_input_declaration,T_tf_input_declaration_type,($2,$3));}
;

reg_opt :
	{$$=SHR2(reg,T_reg_false,());}
	| KEY_REG {$$=SHR2(reg,T_reg_true,());}
;

tf_output_declaration :
	KEY_OUTPUT reg_opt signed_opt range_opt list_of_port_identifiers
		{$$=SHR2(tf_output_declaration,T_tf_output_declaration_reg,($2,$3,$4,$5));}
	| KEY_OUTPUT task_port_type list_of_port_identifiers
		{$$=SHR2(tf_output_declaration,T_tf_output_declaration_type,($2,$3));}
;

tf_inout_declaration :
	KEY_INOUT reg_opt signed_opt range_opt list_of_port_identifiers
		{$$=SHR2(tf_inout_declaration,T_tf_inout_declaration_reg,($2,$3,$4,$5));}
	| KEY_INOUT task_port_type list_of_port_identifiers
		{$$=SHR2(tf_inout_declaration,T_tf_inout_declaration_type,($2,$3));}
;

task_port_type :
	KEY_INTEGER			{$$=SHR2(task_port_type,T_task_port_type_integer,());}
	| KEY_REAL  		{$$=SHR2(task_port_type,T_task_port_type_real,());}
	| KEY_REALTIME	{$$=SHR2(task_port_type,T_task_port_type_realtime,());}
	| KEY_TIME			{$$=SHR2(task_port_type,T_task_port_type_time,());}
;

tf_io_declaration_gen :
	io_type reg_opt signed_opt range_opt port_identifier
		{$$=SHR2(tf_io_declaration_gen,T_tf_io_declaration_gen1,($1,$2,$3,$4,$5));}
	| io_type task_port_type port_identifier
		{$$=SHR2(tf_io_declaration_gen,T_tf_io_declaration_gen2,($1,$2,$3));}
;

/*A.2.8 Block item declarations*/

block_item_declaration :
	 attribute_instance_list  KEY_REG signed_opt range_opt list_of_block_variable_identifiers SEMICOLON
	 	{$$=SHR2(block_item_declaration,T_block_item_declaration_reg,($1,$3,$4,$5));}
|  attribute_instance_list  KEY_INTEGER list_of_block_variable_identifiers SEMICOLON
		{$$=SHR2(block_item_declaration,T_block_item_declaration_integer,($1,$3));}
|  attribute_instance_list  KEY_TIME list_of_block_variable_identifiers SEMICOLON
		{$$=SHR2(block_item_declaration,T_block_item_declaration_time,($1,$3));}
|  attribute_instance_list  KEY_REAL list_of_block_real_identifiers SEMICOLON
		{$$=SHR2(block_item_declaration,T_block_item_declaration_real,($1,$3));}
|  attribute_instance_list  KEY_REALTIME list_of_block_real_identifiers SEMICOLON
		{$$=SHR2(block_item_declaration,T_block_item_declaration_realtime,($1,$3));}
|  attribute_instance_list  event_declaration
		{$$=SHR2(block_item_declaration,T_block_item_declaration_event,($1,$2));}
|  attribute_instance_list  local_parameter_declaration SEMICOLON
		{$$=SHR2(block_item_declaration,T_block_item_declaration_local_param,($1,$2));}
|  attribute_instance_list  parameter_declaration SEMICOLON
		{$$=SHR2(block_item_declaration,T_block_item_declaration_param,($1,$2));}
;

list_of_block_variable_identifiers : 
	block_variable_type comma_block_variable_type_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

comma_block_variable_type_list :
		{
			$$=SHR_LIST_SHR(block_variable_type)();
		}
	| comma_block_variable_type_list COMMA block_variable_type 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

list_of_block_real_identifiers :
	block_real_type comma_block_real_type_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

comma_block_real_type_list :
		{
			$$=SHR_LIST_SHR(block_real_type)();
		}
	| comma_block_real_type_list COMMA block_real_type 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

block_variable_type :
	variable_identifier dimension_list
		{$$=SHR2(block_variable_type,T_block_variable_type,($1,$2));}
;

block_real_type :
	real_identifier dimension_list
		{$$=SHR2(block_real_type,T_block_real_type,($1,$2));}
;


/*A.3 Primitive instances
A.3.1 Primitive instantiation and instances*/

/*gate_instantiation :
	cmos_switchtype delay3_opt cmos_switch_instance comma_cmos_switch_instance_list SEMICOLON
		{T_gate_instantiation_cmos($1,$2,$3::$4)}
	| enable_gatetype drive_strength_opt delay3_opt enable_gate_instance comma_enable_gate_instance_list SEMICOLON
		{T_gate_instantiation_enable($1,$2,$3,$4::$5)}
	| mos_switchtype delay3_opt mos_switch_instance comma_mos_switch_instance_list SEMICOLON
		{T_gate_instantiation_mos($1,$2,$3::$4)}
	| n_input_gatetype drive_strength_opt delay2_opt n_input_gate_instance comma_n_input_gate_instance_list SEMICOLON
		{T_gate_instantiation_input($1,$2,$3,$4::$5)}
	| n_output_gatetype drive_strength_opt delay2_opt n_output_gate_instance comma_n_output_gate_instance_list SEMICOLON
		{T_gate_instantiation_output($1,$2,$3,$4::$5)}
	| pass_en_switchtype delay2_opt pass_enable_switch_instance comma_pass_enable_switch_instance_list SEMICOLON
		{T_gate_instantiation_pass_en($1,$2,$3::$4)}
	| pass_switchtype pass_switch_instance comma_pass_switch_instance_list SEMICOLON
		{T_gate_instantiation_pass($1,$2::$3)}
	| KEY_PULLDOWN pulldown_strength_opt pull_gate_instance comma_pull_gate_instance_list SEMICOLON
		{T_gate_instantiation_pulldown($2,$3::$4)}
	| KEY_PULLUP pullup_strength_opt pull_gate_instance comma_pull_gate_instance_list SEMICOLON
		{T_gate_instantiation_pullup($2,$3::$4)}
;

comma_n_output_gate_instance_list :
	{[]}
	| comma_n_output_gate_instance_list COMMA n_output_gate_instance 
		{$1@$3}
;

comma_pass_enable_switch_instance_list :
	{[]}
	| comma_pass_enable_switch_instance_list COMMA pass_enable_switch_instance 
		{$1@[$3]}
;

comma_pass_switch_instance_list :
	{[]}
	| comma_pass_switch_instance_list COMMA pass_switch_instance 
		{$1@[$3]}
;

comma_pull_gate_instance_list :
	{[]}
	| comma_pull_gate_instance_list COMMA pull_gate_instance 
		{$1@[$3]}
;

comma_cmos_switch_instance_list :
	{[]}
	| comma_cmos_switch_instance_list COMMA cmos_switch_instance 
		{$1@[$3]}
;

comma_enable_gate_instance_list :
	{[]}
	| comma_enable_gate_instance_list COMMA enable_gate_instance  
		{$1@[$3]}
;

comma_mos_switch_instance_list :
	{[]}
	| comma_mos_switch_instance_list COMMA mos_switch_instance 
		{$1@[$3]}
;

comma_n_input_gate_instance_list :
	{[]}
	| comma_n_input_gate_instance_list COMMA n_input_gate_instance  
		{$1@[$3]}
;


delay2_opt :
	{T_delay2_NOSPEC}
	| delay2 {$1}
;

pulldown_strength_opt :
	{T_pulldown_strength_NOSPEC}
	| pulldown_strength {$1}
;

pullup_strength_opt :
	{T_pullup_strength_NOSPEC}
	| pullup_strength {$1}
;

cmos_switch_instance :
	name_of_gate_instance_opt LPARENT output_terminal COMMA input_terminal COMMA ncontrol_terminal COMMA pcontrol_terminal RPARENT
		{T_cmos_switch_instance($1,$3,$5,$7,$9)}
;


name_of_gate_instance_opt :
	{T_name_of_gate_instance_NOSPEC}
	| name_of_gate_instance {$1}
;

enable_gate_instance :
	name_of_gate_instance_opt LPARENT output_terminal COMMA input_terminal COMMA enable_terminal RPARENT
		{T_enable_gate_instance($1,$3,$5,$7)}
;

mos_switch_instance : 
	name_of_gate_instance_opt LPARENT output_terminal COMMA input_terminal COMMA enable_terminal RPARENT
		{T_mos_switch_instance($1,$3,$5,$7)}
;

n_input_gate_instance : 
	name_of_gate_instance_opt LPARENT output_terminal COMMA input_terminal comma_input_terminal_list RPARENT
		{T_n_input_gate_instance($1,$3,$5,$6)}
;

n_output_gate_instance :
	name_of_gate_instance_opt LPARENT output_terminal comma_output_terminal_list COMMA input_terminal RPARENT
		{T_n_output_gate_instance($1,$3,$4,$6)}
;

comma_output_terminal_list :
	{[]}
	| comma_output_terminal_list COMMA output_terminal 
		{$1@[$3]}
;

pass_switch_instance :
	name_of_gate_instance_opt LPARENT inout_terminal COMMA inout_terminal RPARENT
		{T_pass_switch_instance($1,$3,$5)}
;

pass_enable_switch_instance :
	name_of_gate_instance_opt LPARENT inout_terminal COMMA inout_terminal COMMA enable_terminal RPARENT
		{T_pass_enable_switch_instance($1,$3,$5,$7)}
;


pull_gate_instance :
	name_of_gate_instance_opt LPARENT output_terminal RPARENT
		{T_pull_gate_instance($1,$3)}
;

name_of_gate_instance :
	gate_instance_identifier LSQUARE range RSQUARE
		{T_name_of_gate_instance($1,$3)}
;
*/
/*A.3.2 Primitive strengths*/

/*pulldown_strength :
	LPARENT strength0 COMMA strength1 RPARENT
		{T_pulldown_strength01($2,$4)}
	| LPARENT strength1 COMMA strength0 RPARENT
		{T_pulldown_strength10($2,$4)}
	| LPARENT strength0 RPARENT
		{T_pulldown_strength0($2)}
;

pullup_strength :
	LPARENT strength0 COMMA strength1 RPARENT
		{T_pullup_strength01($2,$4)}
	| LPARENT strength1 COMMA strength0 RPARENT
		{T_pullup_strength10($2,$4)}
	| LPARENT strength1 RPARENT
		{T_pullup_strength1($2)}
;

*/
/*A.3.3 Primitive terminals*/
/*enable_terminal : expression {$1} ;
inout_terminal : net_lvalue {$1} ;
input_terminal : expression {$1} ;
ncontrol_terminal : expression {$1} ;
output_terminal : net_lvalue {$1} ;
pcontrol_terminal : expression {$1};

*/

/*A.3.4 Primitive gate and switch types*/

/*cmos_switchtype :
	KEY_CMOS    {record_pos $1T_cmos_switchtype_CMOS}
	| KEY_RCMOS {record_pos $1T_cmos_switchtype_RCMOS}
;

enable_gatetype :
		KEY_BUFIF0 	{T_enable_gatetype__BUFIF0}
	| KEY_BUFIF1 	{T_enable_gatetype__BUFIF1}
	| KEY_NOTIF0 	{T_enable_gatetype__NOTIF0}
	| KEY_NOTIF1	{T_enable_gatetype__NOTIF1}
;

mos_switchtype : 
		KEY_NMOS 	{T_mos_switchtype_NMOS }	
	| KEY_PMOS 	{T_mos_switchtype_PMOS }
	| KEY_RNMOS	{T_mos_switchtype_RNMOS} 
	| KEY_RPMOS	{T_mos_switchtype_RPMOS}
;

n_input_gatetype :
   	KEY_AND  {T_n_input_gatetype_AND }  
	| KEY_NAND {T_n_input_gatetype_NAND}
	| KEY_OR 	 {T_n_input_gatetype_OR 	}
	| KEY_NOR  {T_n_input_gatetype_NOR }
	| KEY_XOR  {T_n_input_gatetype_XOR }
	| KEY_XNOR {T_n_input_gatetype_XNOR} 
;

n_output_gatetype :
	KEY_BUF   {T_n_output_gatetype_BUF}
	| KEY_NOT {T_n_output_gatetype_NOT}
;

pass_en_switchtype :
	  KEY_TRANIF0 {T_pass_en_switchtype_TRANIF0 } 
	| KEY_TRANIF1 {T_pass_en_switchtype_TRANIF1 }   
	| KEY_RTRANIF1{T_pass_en_switchtype_RTRANIF1}  
	| KEY_RTRANIF0{T_pass_en_switchtype_RTRANIF0} 
;
pass_switchtype :
	  KEY_TRAN  {T_pass_switchtype_TRAN } 
	| KEY_RTRAN {T_pass_switchtype_RTRAN} 
;
*/


/*A.4 Module instantiation and generate construct
A.4.1 Module instantiation*/

module_instantiation :
	module_identifier parameter_value_assignment_opt module_instance comma_module_instance_list SEMICOLON
		{
			auto p=$4;
			p->push_front($3);
			$$=SHR2(module_instantiation,T_module_instantiation,($1,$2,p));
		}
;

comma_module_instance_list :
		{
			$$=SHR_LIST_SHR(module_instance)();
		}
	| comma_module_instance_list COMMA module_instance  
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

parameter_value_assignment_opt :
	{$$=SHR2(parameter_value_assignment,T_parameter_value_assignment_NOSPEC,());}
	| parameter_value_assignment {$$=$1;}
;

parameter_value_assignment :
	JING LPARENT list_of_parameter_assignments RPARENT
		{$$=$3;}
;

list_of_parameter_assignments :
	ordered_parameter_assignment comma_ordered_parameter_assignment_list
		{
			auto p=$2;
			p->push_front($1);
			$$=SHR2(parameter_value_assignment,T_parameter_value_assignment_order,(p));
		} 
	| named_parameter_assignment comma_named_parameter_assignment_list
		{
			auto p=$2;
			p->push_front($1);
			$$=SHR2(parameter_value_assignment,T_parameter_value_assignment_named,(p));
		}
;

comma_ordered_parameter_assignment_list :
		{
			$$=SHR_LIST_SHR(expression)();
		}
	| comma_ordered_parameter_assignment_list COMMA ordered_parameter_assignment 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

comma_named_parameter_assignment_list :
		{
			$$=SHR_LIST_SHR(named_parameter_assignment)();
		}
	| comma_named_parameter_assignment_list COMMA named_parameter_assignment  
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

ordered_parameter_assignment :
	expression {$$=$1;}
;

named_parameter_assignment :
	PERIOD parameter_identifier LPARENT mintypmax_expression_opt RPARENT
		{$$=SHR2(named_parameter_assignment,T_named_parameter_assignment,($2,$4));}
;

mintypmax_expression_opt :
	{$$=SHR2(mintypmax_expression,T_mintypmax_expression_NOSPEC,());}
	| mintypmax_expression {$$=$1;}
;

module_instance :
	name_of_module_instance LPARENT list_of_port_connections RPARENT
		{$$=SHR2(module_instance,T_module_instance,($1,$3));}
;

name_of_module_instance :
	module_instance_identifier range_opt
		{$$=SHR2(name_of_module_instance,T_name_of_module_instance,($1,$2));}
;

list_of_port_connections :
	ordered_port_connection comma_ordered_port_connection_list
		{
			auto p=$2;
			p->push_front($1);
			$$=SHR2(list_of_port_connections,T_list_of_port_connections_ordered,(p));
		}
	| named_port_connection comma_named_port_connection_list
		{
			auto p=$2;
			p->push_front($1);
			$$=SHR2(list_of_port_connections,T_list_of_port_connections_named,(p));
		}
;

comma_ordered_port_connection_list :
		{
			$$=SHR_LIST_SHR(ordered_port_connection)();
		}
	| comma_ordered_port_connection_list COMMA ordered_port_connection 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

comma_named_port_connection_list :
		{
			$$=SHR_LIST_SHR(named_port_connection)();
		}
	| comma_named_port_connection_list COMMA named_port_connection 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

ordered_port_connection :
	attribute_instance_list expression_opt
		{$$=SHR2(ordered_port_connection,T_ordered_port_connection,($1,$2));}
;

expression_opt :
	{$$=SHR2(expression,T_expression_NOSPEC,());}
	| expression {$$=$1;}
;

named_port_connection :
	attribute_instance_list PERIOD port_identifier LPARENT expression_opt RPARENT
		{$$=SHR2(named_port_connection,T_named_port_connection,($1,$3,$5));}
;


/*A.4.2 Generate construct*/
generate_region :
	KEY_GENERATE module_or_generate_item_list KEY_ENDGENERATE
		{$$=SHR2(generate_region,T_generate_region,($2));}
;

module_or_generate_item_list :
		{
			$$=SHR_LIST_SHR(module_item)();
		}
	| module_or_generate_item_list module_or_generate_item  
		{
			auto p=$1;
			p->push_back($2);
			$$=p;
		}
;

genvar_declaration :
	KEY_GENVAR list_of_genvar_identifiers SEMICOLON
		{$$=SHR2(genvar_declaration,T_genvar_declaration,($2));}
;

list_of_genvar_identifiers :
	genvar_identifier comma_genvar_identifier_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

comma_genvar_identifier_list :
		{
			$$=SHR_LIST_SHR(identifier)();
		}
	| comma_genvar_identifier_list COMMA genvar_identifier  
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

loop_generate_construct :
	KEY_FOR LPARENT genvar_initialization SEMICOLON expression SEMICOLON genvar_iteration RPARENT generate_block
		{$$=SHR2(loop_generate_construct,T_loop_generate_construct,($3,$5,$7,$9));}
;

genvar_initialization :
	genvar_identifier EQU1 expression
		{$$=SHR2(genvar_initialization,T_genvar_initialization,($1,$3));}
;

genvar_iteration :
	genvar_identifier EQU1 expression
		{$$=SHR2(genvar_iteration,T_genvar_iteration,($1,$3));}
;

conditional_generate_construct :
	if_generate_construct
		{$$=SHR2(conditional_generate_construct,T_conditional_generate_construct_if,($1));}
	| case_generate_construct
		{$$=SHR2(conditional_generate_construct,T_conditional_generate_construct_case,($1));}
;

if_generate_construct :
	KEY_IF LPARENT expression RPARENT generate_block_or_null
	else_generate_block_or_null_opt
		{$$=SHR2(if_generate_construct,T_if_generate_construct,($3,$5,$6));}
;

else_generate_block_or_null_opt :
	{$$=SHR2(generate_block,T_generate_block_NOSPEC,());}
	| KEY_ELSE generate_block_or_null
		{$$=$2;}
;

case_generate_construct :
	KEY_CASE LPARENT expression RPARENT
	case_generate_item case_generate_item_list KEY_ENDCASE
		{
			auto p=$6;
			p->push_front($5);
			$$=SHR2(case_generate_construct,T_case_generate_construct,($3,p));
		}
;

case_generate_item_list :
		{
			$$=SHR_LIST_SHR(case_generate_item)();
		}
	| case_generate_item_list case_generate_item 
		{
			auto p=$1;
			p->push_back($2);
			$$=p;
		}
;

case_generate_item :
	expression comma_expression_list COLON generate_block_or_null
		{
			auto p=$2;
			p->push_front($1);
			$$=SHR2(case_generate_item,T_case_generate_item_case,(p,$4));
		}
	| KEY_DEFAULT colon_opt  generate_block_or_null
		{$$=SHR2(case_generate_item,T_case_generate_item_default,($3));}
;

colon_opt :
	{$$=SHR2(colon_opt,T_colon_opt_false,());}
	| COLON {$$=SHR2(colon_opt,T_colon_opt_true,());}
;

generate_block :
	module_or_generate_item
		{$$=SHR2(generate_block,T_generate_block_mgi,($1));}
	| KEY_BEGIN colon_generate_block_identifier_opt module_or_generate_item_list KEY_END
		{$$=SHR2(generate_block,T_generate_block_begin,($2,$3));}
;

colon_generate_block_identifier_opt :
	{$$=SHR2(identifier,T_identifier_NOSPEC,());}
	| COLON generate_block_identifier
		{$$=$2;}
;

generate_block_or_null :
	generate_block
		{$$=$1;}
	| SEMICOLON
		{$$=SHR2(generate_block,T_generate_block_NOSPEC,());}
;


/*A.5 UDP declaration and instantiation
A.5.1 UDP declaration*/

/*udp_declaration :
	attribute_instance_list KEY_PRIMITIVE udp_identifier LPARENT udp_port_list RPARENT SEMICOLON
	udp_port_declaration udp_port_declaration_list
	udp_body
	KEY_ENDPRIMITIVE
		{T_udp_declaration_1($1,$3,$5,$8::$9,$10)}
| attribute_instance_list KEY_PRIMITIVE udp_identifier LPARENT udp_declaration_port_list RPARENT SEMICOLON
	udp_body
	KEY_ENDPRIMITIVE
		{T_udp_declaration_2($1,$3,$5,$8)}
;


udp_port_declaration_list :
	{[]}
	| udp_port_declaration_list udp_port_declaration 
		{$1@[$2]}
;
*/
/*A.5.2 UDP ports*/
/*
udp_port_list :
	output_port_identifier COMMA input_port_identifier comma_input_port_identifier_list
		{T_udp_port_list($1,$3::$4)}
;

comma_input_port_identifier_list :
	{[]}
	| comma_input_port_identifier_list COMMA input_port_identifier 
		{$1@[$3]}
;

udp_declaration_port_list :
	udp_output_declaration COMMA udp_input_declaration comma_udp_input_declaration_list
		{T_udp_declaration_port_list($1,$3::$4)}
;

comma_udp_input_declaration_list :
	{[]}
	| comma_udp_input_declaration_list COMMA udp_input_declaration 
		{$1@[$3]}
;


udp_port_declaration :
	udp_output_declaration SEMICOLON
		{T_udp_port_declaration_out($1)}
	| udp_input_declaration SEMICOLON
		{T_udp_port_declaration_input($1)}
	| udp_reg_declaration SEMICOLON
		{T_udp_port_declaration_reg($1)}
;

udp_output_declaration :
	attribute_instance_list KEY_OUTPUT port_identifier
		{T_udp_output_declaration_output($1,$3)}
	| attribute_instance_list KEY_OUTPUT KEY_REG port_identifier equ1_expression_opt
		{T_udp_output_declaration_reg($1,$4,$5)}
;

udp_input_declaration : 
	attribute_instance_list KEY_INPUT list_of_port_identifiers
		{T_udp_input_declaration($1,$3)}
;

udp_reg_declaration :
	attribute_instance_list  KEY_REG variable_identifier
		{T_udp_reg_declaration($1,$3)}
;
*/
/*A.5.3 UDP body*/
/*
udp_body : 
	combinational_body 
		{T_udp_body_comb($1)}
	| sequential_body
		{T_udp_body_seq($1)}
;


combinational_body :
	KEY_TABLE combinational_entry combinational_entry_list KEY_ENDTABLE
		{$2::$3}
;

combinational_entry_list :
	{[]}
	| combinational_entry_list combinational_entry 
		{$1@[$2]}
;

combinational_entry :
	level_input_list COLON output_symbol SEMICOLON
		{T_combinational_entry($1,$3)}
;

sequential_body :
	udp_initial_statement_opt KEY_TABLE sequential_entry sequential_entry_list KEY_ENDTABLE
		{T_sequential_body($1,$3::$4)}
;

udp_initial_statement_opt :
	{T_udp_initial_statement_NOSPEC}
	| udp_initial_statement
		{$1}
;


sequential_entry_list :
	{[]}
	| sequential_entry_list sequential_entry 
		{$1@[$2]}
;

udp_initial_statement :
	KEY_INITIAL output_port_identifier EQU1 init_val SEMICOLON
		{T_udp_initial_statement($2,$4)}
;

*/

/*init_val ::= 1'b0 | 1'b1 | 1'bx | 1'bX | 1'B0 | 1'B1 | 1'Bx | 1'BX | 1 | 0*/
/*actually lex only return number*/
/*init_val :
	BINARY_NUMBER  
		{T_init_val_bin(get1 $1, get2 $1, get3 $1)}
	| UNSIGNED_NUMBER
		{T_init_val_unsigned(get1 $1, get2 $1, get3 $1)}
;

sequential_entry :
	seq_input_list COLON current_state COLON next_state SEMICOLON
		{T_sequential_entry($1,$3,$5)}
;

seq_input_list :
	level_input_list 
		{T_seq_input_list_level($1)}
	| edge_input_list
		{T_seq_input_list_edge($1)}
;

level_input_list :
	level_symbol_list level_symbol 
		{$1@[$2]}
;

level_symbol_list :
	{[]}
	| level_symbol_list level_symbol 
		{$1@[$2]}
;

edge_input_list :
	level_symbol_list edge_indicator level_symbol_list
		{T_edge_input_list($1,$2,$3)}
;

edge_indicator :
	LPARENT level_symbol level_symbol RPARENT 
		{T_edge_indicator_level($2,$3)}
	| edge_symbol
		{T_edge_indicator_edge($1)}
;
*/
/*current_state : level_symbol
next_state ::= output_symbol | -
output_symbol ::= 0 | 1 | x | X
level_symbol ::= 0 | 1 | x | X | ? | b | B
edge_symbol ::= r | R | f | F | p | P | n | N | *
*/
/*lexer only return UNSIGNED_NUMBER, SIMPLE_IDENTIFIER and * and -*/

/*edge_symbol :
	SIMPLE_IDENTIFIER	{T_edge_symbol_SIMID(get1 $1, get2 $1, get3 $1)}
	| OP2_MULTIPLE	{T_edge_symbol_MUL(get1 $1, get2 $1)}
;

level_symbol :
	UNSIGNED_NUMBER 
	 {T_level_symbol_UNSIGNED_NUMBER(get1 $1, get2 $1, get3 $1)}
	| SIMPLE_IDENTIFIER  {T_level_symbol_SIMID(get1 $1, get2 $1, get3 $1)}
	| OP2_QUESTION {T_level_symbol_QUESTION(get1 $1, get2 $1)}
;

output_symbol :
	UNSIGNED_NUMBER 
	 {T_output_symbol_UNSIGNED_NUMBER(get1 $1, get2 $1, get3 $1)}
	| SIMPLE_IDENTIFIER  {T_output_symbol_SIMID(get1 $1, get2 $1, get3 $1)}
;

next_state :
	UNSIGNED_NUMBER 
	 {T_next_state_UNSIGNED_NUMBER(get1 $1, get2 $1, get3 $1)}
	| SIMPLE_IDENTIFIER  {T_next_state_SIMID(get1 $1, get2 $1, get3 $1)}
	| OP2_SUB  {T_next_state_SUB(get1 $1, get2 $1)}
;

current_state :
	UNSIGNED_NUMBER 
	 {T_current_state_UNSIGNED_NUMBER(get1 $1, get2 $1, get3 $1)}
	| SIMPLE_IDENTIFIER  
		{T_current_state_SIMID(get1 $1, get2 $1, get3 $1)}
	| OP2_QUESTION 
		{T_current_state_OP2_QUESTION(get1 $1, get2 $1)}
;
	
*/



/*A.5.4 UDP instantiation*/
/*udp_instantiation :
	udp_identifier drive_strength_opt delay2_opt
		udp_instance comma_udp_instance_list  ;
		{T_udp_instantiation($1,$2,$3,$4::$5)}
;

comma_udp_instance_list :
	{[]}
	| comma_udp_instance_list COMMA udp_instance 
		{$1@[$3]}
;

udp_instance :
	name_of_udp_instance_opt LPARENT output_terminal COMMA input_terminal comma_input_terminal_list RPARENT
	{T_udp_instance($1,$3,$5::$6)}
;

name_of_udp_instance_opt :
	{T_name_of_udp_instance_NOSPEC}
	| name_of_udp_instance
			{$1}
;

comma_input_terminal_list :
	{[]}
	| comma_input_terminal_list COMMA input_terminal 
		{$1@[$3]}
;

name_of_udp_instance :
	udp_instance_identifier range_opt
		{T_name_of_udp_instance($1,$2)}
;
*/
/*A.6 Behavioral statements
A.6.1 Continuous assignment statements*/

continuous_assign :
	KEY_ASSIGN drive_strength_opt delay3_opt list_of_net_assignments SEMICOLON
		{$$=SHR2(continuous_assign,T_continuous_assign,($2,$3,$4));}
;

list_of_net_assignments :
	net_assignment comma_net_assignment_list
		{
			auto p=$2;
			p->push_front($1);
			$$=p;
		}
;

comma_net_assignment_list :
		{
			$$=SHR_LIST_SHR(net_assignment)();
		}
	| comma_net_assignment_list COMMA net_assignment 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

net_assignment :
	net_lvalue EQU1 expression
		{$$=SHR2(net_assignment,T_net_assignment,($1,$3));}
;

/*A.6.2 Procedural blocks and assignments*/

initial_construct :
	KEY_INITIAL statement
		{$$=SHR2(initial_construct,T_initial_construct,($2));}
;

always_construct :
	KEY_ALWAYS statement
		{$$=SHR2(always_construct,T_always_construct,($2));}
;

blocking_assignment :
	net_lvalue EQU1 delay_or_event_control_opt expression
		{$$=SHR2(blocking_assignment,T_blocking_assignment,($1,$3,$4));}
;

delay_or_event_control_opt :
	{$$=SHR2(delay_or_event_control,T_delay_or_event_control_NOSPEC,());}
	| delay_or_event_control
		{$$=$1;}
;

nonblocking_assignment :
	net_lvalue OP2_LE delay_or_event_control_opt expression
		{$$=SHR2(nonblocking_assignment,T_nonblocking_assignment,($1,$3,$4));}
;

procedural_continuous_assignments :
	KEY_ASSIGN net_assignment
		{$$=SHR2(procedural_continuous_assignments,T_procedural_continuous_assignments_assign,($2));}
	| KEY_DEASSIGN net_lvalue
		{$$=SHR2(procedural_continuous_assignments,T_procedural_continuous_assignments_deassign,($2));}
	| KEY_FORCE net_assignment
		{$$=SHR2(procedural_continuous_assignments,T_procedural_continuous_assignments_force1,($2));}
	| KEY_RELEASE net_lvalue
		{$$=SHR2(procedural_continuous_assignments,T_procedural_continuous_assignments_release1,($2));}
;


/*A.6.3 Parallel and sequential blocks*/

par_block :
	KEY_FORK colon_block_identifier_opt
	statement_or_block_item_list
	KEY_JOIN
		{$$=SHR2(par_block,T_par_block,($2,$3));}
;

colon_block_identifier_opt :
	{$$=SHR2(colon_block_identifier,T_colon_block_identifier_NOSPEC,());}
	| COLON block_identifier 
		{$$=SHR2(colon_block_identifier,T_colon_block_identifier,($2));}
;

/*statement_list :
	{[]}
	| statement_list statement 
		{$1@[$2]}
;
*/
seq_block :
	KEY_BEGIN colon_block_identifier_opt 
	statement_or_block_item_list
	KEY_END
		{$$=SHR2(seq_block,T_seq_block,($2,$3));}
;
statement_or_block_item_list :
		{
			$$=SHR_LIST_SHR(statement_or_block_item)();
		}
	| statement_or_block_item_list statement_or_block_item 
		{
			auto p=$1;
			p->push_back($2);
			$$=p;
		}
;

statement_or_block_item :
	statement {$$=SHR2(statement_or_block_item,T_statement_or_block_item_statement,($1));}
	| block_item_declaration {$$=SHR2(statement_or_block_item,T_statement_or_block_item_block,($1));}
;

/*A.6.4 Statements*/

statement :
		attribute_instance_list blocking_assignment SEMICOLON
			{$$=SHR2(statement,T_statement_blocking_assignment,($1,$2));}
	| attribute_instance_list case_statement
			{$$=SHR2(statement,T_statement_case_statement,($1,$2));}
	| attribute_instance_list conditional_statement
			{$$=SHR2(statement,T_statement_conditional_statement,($1,$2));}
	| attribute_instance_list disable_statement
			{$$=SHR2(statement,T_statement_disable_statement,($1,$2));}
	| attribute_instance_list event_trigger
			{$$=SHR2(statement,T_statement_event_trigger,($1,$2));}
	| attribute_instance_list loop_statement
			{$$=SHR2(statement,T_statement_loop_statement,($1,$2));}
	| attribute_instance_list nonblocking_assignment SEMICOLON
			{$$=SHR2(statement,T_statement_nonblocking_assignment,($1,$2));}
	| attribute_instance_list par_block
			{$$=SHR2(statement,T_statement_par_block,($1,$2));}
	| attribute_instance_list procedural_continuous_assignments SEMICOLON
			{$$=SHR2(statement,T_statement_procedural_continuous_assignments,($1,$2));}
	| attribute_instance_list procedural_timing_control_statement
			{$$=SHR2(statement,T_statement_procedural_timing_control_statement,($1,$2));}
	| attribute_instance_list seq_block
			{$$=SHR2(statement,T_statement_seq_block,($1,$2));}
	| attribute_instance_list system_task_enable
			{$$=SHR2(statement,T_statement_system_task_enable,($1,$2));}
	| attribute_instance_list task_enable
			{$$=SHR2(statement,T_statement_task_enable,($1,$2));}
	| attribute_instance_list wait_statement
			{$$=SHR2(statement,T_statement_wait_statement,($1,$2));}



statement_or_null :
	statement
		{$$=$1;}
	| attribute_instance_list SEMICOLON
		{$$=SHR2(statement,T_statement_NOSPEC,($1));}
;

function_statement :
	statement
		{$$=$1;}
;

/*A.6.5 Timing control statements*/

delay_control :
	JING delay_value
		{$$=SHR2(delay_control,T_delay_control_delay_value,($2));}
	| JING LPARENT mintypmax_expression RPARENT
		{$$=SHR2(delay_control,T_delay_control_mintypmax_expression,($3));}
;

delay_or_event_control :
	delay_control
		{$$=SHR2(delay_or_event_control,T_delay_or_event_control_delay_control,($1));}
	| event_control
		{$$=SHR2(delay_or_event_control,T_delay_or_event_control_event_control,($1));}
	| KEY_REPEAT LPARENT expression RPARENT event_control
		{$$=SHR2(delay_or_event_control,T_delay_or_event_control_3,($3,$5));}
;


disable_statement :
	KEY_DISABLE hierarchical_identifier SEMICOLON
		{$$=SHR2(disable_statement,T_disable_statement,($2));}
;


event_control :
	AT hierarchical_identifier
		{$$=SHR2(event_control,T_event_control_eventid,($2));}
	| AT LPARENT event_expression_orcomma_list RPARENT
		{$$=SHR2(event_control,T_event_control_event_exp,($3));}
	| AT OP2_MULTIPLE
		{$$=SHR2(event_control,T_event_control_start,());}
	| AT LPARENT OP2_MULTIPLE RPARENT
		{$$=SHR2(event_control,T_event_control_start,());}
	| AT LPARENTSTART RPARENT
		{$$=SHR2(event_control,T_event_control_start,());}
	| AT LPARENT RPARENTSTART
		{$$=SHR2(event_control,T_event_control_start,());}
;

event_trigger :
	IMPLY hierarchical_identifier  SEMICOLON
		{$$=SHR2(event_trigger,T_event_trigger,($2));}
;

event_expression :
	expression
		{$$=SHR2(event_expression,T_event_expression_exp,($1));}
	| KEY_POSEDGE expression
		{$$=SHR2(event_expression,T_event_expression_pos,($2));}
	| KEY_NEGEDGE expression
		{$$=SHR2(event_expression,T_event_expression_neg,($2));}


event_expression_orcomma_list :
	event_expression 
		{
			auto p = SHR_LIST_SHR(event_expression)();
			p->push_back($1);
			$$=p;
		}
	| event_expression_orcomma_list or_comma event_expression
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

or_comma :
	KEY_OR	{$$=0;}
	| COMMA {$$=0;}
;
procedural_timing_control :
	delay_control
		{$$=SHR2(procedural_timing_control,T_procedural_timing_control_delay,($1));}
	| event_control
		{$$=SHR2(procedural_timing_control,T_procedural_timing_control_event,($1));}
;


procedural_timing_control_statement :
	procedural_timing_control statement_or_null
		{$$=SHR2(procedural_timing_control_statement,T_procedural_timing_control_statement,($1,$2));}
;

wait_statement :
	KEY_WAIT LPARENT expression RPARENT statement_or_null
		{$$=SHR2(wait_statement,T_wait_statement,($3,$5));}
;

/*A.6.6 Conditional statements*/
conditional_statement :
	KEY_IF LPARENT expression RPARENT
	statement_or_null else_statement_or_null_opt
		{$$=SHR2(conditional_statement,T_conditional_statement_ifelse,($3,$5,$6));}
/*	| KEY_IF LPARENT expression RPARENT statement_or_null
		else_if_lp_expression_rp_statement_or_null_list
		else_statement_or_null_opt
		{$$=SHR2(,T_conditional_statement_ifelseif,($3,$5,$6,$7));}*/
;

else_statement_or_null_opt :
	{
		auto p = SHR_LIST_SHR(attribute_instance)();
		$$=SHR2(statement,T_statement_NOSPEC ,(p));
	}
	| KEY_ELSE statement_or_null
		{$$=$2;}
;

/*
else_if_lp_expression_rp_statement_or_null_list :
	{[]}
	| else_if_lp_expression_rp_statement_or_null_list else_if_lp_expression_rp_statement_or_null 
		{$1@[$2]}
;


else_if_lp_expression_rp_statement_or_null :
	KEY_ELSE KEY_IF LPARENT expression RPARENT statement_or_null
		{T_elseif($4,$6)}
;
*/



/*A.6.7 Case statements*/
case_statement :
	KEY_CASE LPARENT expression RPARENT
	case_item case_item_list
	KEY_ENDCASE
			{
				auto p=$6;
				p->push_front($5);
				$$=SHR2(case_statement,T_case_statement_case,($3,p));
			}
	| KEY_CASEZ LPARENT expression RPARENT
		case_item case_item_list
		KEY_ENDCASE
			{
				auto p=$6;
				p->push_front($5);
				$$=SHR2(case_statement,T_case_statement_casez,($3,p));
			}
	| KEY_CASEX LPARENT expression RPARENT
		case_item case_item_list
		KEY_ENDCASE
			{
				auto p=$6;
				p->push_front($5);
				$$=SHR2(case_statement,T_case_statement_casex,($3,p));
			}
;

case_item_list :
		{
			$$=SHR_LIST_SHR(case_item)();
		}
	| case_item_list case_item 
		{
			auto p=$1;
			p->push_back($2);
			$$=p;
		}
;

case_item :
	expression comma_expression_list COLON statement_or_null
		{
			auto p=$2;
			p->push_front($1);
			$$=SHR2(case_item,T_case_item,(p,$4));
		}
	| KEY_DEFAULT colon_opt statement_or_null
		{$$=SHR2(case_item,T_case_item_default,($2,$3));}
;


comma_expression_list :
		{
			$$=SHR_LIST_SHR(expression)();
		}
	| comma_expression_list COMMA expression 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

/*A.6.8 Looping statements*/
loop_statement :
	KEY_FOREVER statement
		{$$=SHR2(loop_statement,T_loop_statement_forever,($2));}
	| KEY_REPEAT LPARENT expression RPARENT statement
		{$$=SHR2(loop_statement,T_loop_statement_repeat,($3,$5));}
	| KEY_WHILE LPARENT expression RPARENT statement
		{$$=SHR2(loop_statement,T_loop_statement_while,($3,$5));}
	| KEY_FOR LPARENT net_assignment SEMICOLON expression SEMICOLON net_assignment RPARENT statement
		{$$=SHR2(loop_statement,T_loop_statement_for,($3,$5,$7,$9));}
;




/*A.6.9 Task enable statements*/
system_task_enable :
	system_function_identifier lp_expression_opt_comma_expression_list_rp_opt SEMICOLON
		{$$=SHR2(system_task_enable,T_system_task_enable,($1,$2));}
;

lp_expression_opt_comma_expression_list_rp_opt :
		{
			$$=SHR_LIST_SHR(expression)();
		}
	| lp_expression_opt_comma_expression_list_rp {$$=$1;}
;


lp_expression_opt_comma_expression_list_rp :
	LPARENT expression comma_expression_list RPARENT
		{
			auto p=$3;
			p->push_front($2);
			$$=p;
		}
;


task_enable :
	hierarchical_identifier lp_expression_opt_comma_expression_list_rp_opt SEMICOLON
		{$$=SHR2(task_enable,T_task_enable,($1,$2));}
;



/*A.7 Specify section
A.7.1 Specify block declaration*/
/*specify_block :
	KEY_SPECIFY specify_item_list KEY_ENDSPECIFY
		{T_specify_block($2)}
;

specify_item_list :
	{[]}
	| specify_item_list specify_item 
		{$1@[$2]}
;


specify_item :
	specparam_declaration
		{T_specify_item_specparam($1)}
	| pulsestyle_declaration
		{T_specify_item_pulsestyle($1)}
	| showcancelled_declaration
		{T_specify_item_showcancelled($1)}
	| path_declaration
		{T_specify_item_path($1)}
	| system_timing_check
		{T_specify_item_system($1)}
;


pulsestyle_declaration :
	KEY_PULSESTYLE_ONEVENT list_of_path_outputs SEMICOLON
		{T_pulsestyle_declaration_oneevent($2)}
	| KEY_PULSESTYLE_ONDETECT list_of_path_outputs SEMICOLON
		{T_pulsestyle_declaration_onedetect($2)}
;



showcancelled_declaration :
	KEY_SHOWCANCELLED list_of_path_outputs SEMICOLON
		{T_showcancelled_declaration_show($2)}
	| KEY_NOSHOWCANCELLED list_of_path_outputs SEMICOLON
		{T_showcancelled_declaration_noshow($2)}
;


*/
/*A.7.2 Specify path declarations*/
/*path_declaration :
	simple_path_declaration SEMICOLON
		{T_path_declaration_simple($1)}
	| edge_sensitive_path_declaration SEMICOLON
		{T_path_declaration_edge($1)}
	| state_dependent_path_declaration SEMICOLON
		{T_path_declaration_state($1)}
;


simple_path_declaration :
	parallel_path_description EQU1 path_delay_value
		{T_simple_path_declaration_parallel($1,$3)}
	| full_path_description EQU1 path_delay_value
		{T_simple_path_declaration_full($1,$3)}
;



parallel_path_description :
	LPARENT specify_input_terminal_descriptor polarity_operator_opt IMPLY2 specify_output_terminal_descriptor RPARENT
		{T_parallel_path_description($2,$3,$5)}
;

polarity_operator_opt :
	{T_polarity_operator_NOSPEC}
	| polarity_operator {$1}
;

full_path_description :
	LPARENT list_of_path_inputs  polarity_operator_opt IMPLYSTART list_of_path_outputs RPARENT
		{T_full_path_description($2,$3,$5)}
;


list_of_path_inputs :
	specify_input_terminal_descriptor comma_specify_input_terminal_descriptor_list
		{$1::$2}
;

comma_specify_input_terminal_descriptor_list :
	{[]}
	| comma_specify_input_terminal_descriptor_list COMMA specify_input_terminal_descriptor 
		{$1@$3}
;


list_of_path_outputs :
	specify_output_terminal_descriptor comma_specify_output_terminal_descriptor_list
		{$1::$2}
;

comma_specify_output_terminal_descriptor_list :
	{[]}
	| comma_specify_output_terminal_descriptor_list COMMA specify_output_terminal_descriptor 
		{$1@[$3]}
;

*/
/*A.7.3 Specify block terminals*/
/*specify_input_terminal_descriptor :
	input_identifier lsquare_range_expression_rsquare_opt
		{T_specify_input_terminal_descriptor($1,$2)}
;

specify_output_terminal_descriptor :
	output_identifier lsquare_range_expression_rsquare_opt
		{T_specify_output_terminal_descriptor($1,$2)}
;

input_identifier :
	identifier {$1}
;



output_identifier :
	identifier {$1}
;

*/
/*A.7.4 Specify path delays*/
/*path_delay_value :
	list_of_path_delay_expressions
		{$1}
	| LPARENT list_of_path_delay_expressions RPARENT
		{$2}
;



list_of_path_delay_expressions :
	mintypmax_expression
		{T_list_of_mintypmax_expressions_1($1)}
	| mintypmax_expression COMMA mintypmax_expression
		{T_list_of_mintypmax_expressions_2($1,$3)}
	| mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression
		{T_list_of_mintypmax_expressions_3($1,$3,$5)}
	| mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression COMMA	mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression
		{T_list_of_mintypmax_expressions_6($1,$3,$5,$7,$9,$11)}
	| mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression COMMA	mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression COMMA 	mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression
		{T_list_of_mintypmax_expressions_12($1,$3,$5,$7,$9,$11,$13,$15,$17,$19,$21,$23)}
;

edge_sensitive_path_declaration :
	parallel_edge_sensitive_path_description EQU1 path_delay_value
		{T_edge_sensitive_path_declaration_parallel($1,$3)}
	| full_edge_sensitive_path_description EQU1 path_delay_value
		{T_edge_sensitive_path_declaration_full($1,$3)}
;


parallel_edge_sensitive_path_description :
LPARENT edge_identifier_opt  specify_input_terminal_descriptor IMPLY2
LPARENT specify_output_terminal_descriptor polarity_operator_opt COLON data_source_expression RPARENT RPARENT
		{T_parallel_edge_sensitive_path_description($2,$3,$6,$7,$9)}
;

edge_identifier_opt :
	{T_edge_identifier_NOSPEC}
	| edge_identifier {$1}
;

full_edge_sensitive_path_description :
	LPARENT edge_identifier_opt list_of_path_inputs IMPLYSTART
LPARENT list_of_path_outputs polarity_operator_opt COLON data_source_expression RPARENT RPARENT
		{T_full_edge_sensitive_path_description($2,$3,$6,$7,$9)}
;

data_source_expression :
	expression
	{$1}
;


edge_identifier :
	KEY_POSEDGE  {T_edge_identifier_POS}
	| KEY_NEGEDGE {T_edge_identifier_NEG}
;


state_dependent_path_declaration :
	KEY_IF LPARENT module_path_expression RPARENT simple_path_declaration
		{T_state_dependent_path_declaration_simple($3,$5)}
	| KEY_IF LPARENT module_path_expression RPARENT edge_sensitive_path_declaration
		{T_state_dependent_path_declaration_edge($3,$5)}
	| KEY_IFNONE simple_path_declaration
		{T_state_dependent_path_declaration_ifnone($2)}
;


polarity_operator :
	OP2_ADD  {T_polarity_operator_ADD}
	| OP2_SUB {T_polarity_operator_SUB}
;

*/
/*A.7.5 System timing checks
A.7.5.1 System timing check commands*/
/* no time to do*/
/*system_timing_check :
$setup_timing_check
| $hold_timing_check
| $setuphold_timing_check
| $recovery_timing_check
| $removal_timing_check
| $recrem_timing_check
| $skew_timing_check
| $timeskew_timing_check
| $fullskew_timing_check
| $period_timing_check
| $width_timing_check
| $nochange_timing_check
$setup_timing_check ::=
$setup ( data_event , reference_event , timing_check_limit [ , [ notifier ] ] ) ;
$hold_timing_check ::=
$hold ( reference_event , data_event , timing_check_limit [ , [ notifier ] ] ) ;
$setuphold_timing_check ::=
$setuphold ( reference_event , data_event , timing_check_limit , timing_check_limit
[ , [ notifier ] [ , [ stamptime_condition ] [ , [ checktime_condition ]
[ , [ delayed_reference ] [ , [ delayed_data ] ] ] ] ] ] ) ;
$recovery_timing_check ::=
$recovery ( reference_event , data_event , timing_check_limit [ , [ notifier ] ] ) ;
$removal_timing_check ::=
$removal ( reference_event , data_event , timing_check_limit [ , [ notifier ] ] ) ;
$recrem_timing_check ::=
$recrem ( reference_event , data_event , timing_check_limit , timing_check_limit
[ , [ notifier ] [ , [ stamptime_condition ] [ , [ checktime_condition ]
[ , [ delayed_reference ] [ , [ delayed_data ] ] ] ] ] ] ) ;
$skew_timing_check ::=
$skew ( reference_event , data_event , timing_check_limit [ , [ notifier ] ] ) ;
$timeskew_timing_check ::=
$timeskew ( reference_event , data_event , timing_check_limit
[ , [ notifier ] [ , [ event_based_flag ] [ , [ remain_active_flag ] ] ] ] ) ;
$fullskew_timing_check ::=
$fullskew ( reference_event , data_event , timing_check_limit , timing_check_limit
[ , [ notifier ] [ , [ event_based_flag ] [ , [ remain_active_flag ] ] ] ] ) ;
$period_timing_check ::=
$period ( controlled_reference_event , timing_check_limit [ , [ notifier ] ] ) ;
$width_timing_check ::=
$width ( controlled_reference_event , timing_check_limit
[ , threshold [ , notifier ] ] ) ;
$nochange_timing_check ::=
$nochange ( reference_event , data_event , start_edge_offset ,
end_edge_offset [ , [ notifier ] ] ) ;
*/

/*A.7.5.2 System timing check command arguments*/
/*
checktime_condition ::= mintypmax_expression
controlled_reference_event ::= controlled_timing_check_event
data_event ::= timing_check_event
delayed_data ::=
terminal_identifier
| terminal_identifier [ mintypmax_expression ]
delayed_reference ::=
terminal_identifier
| terminal_identifier [ mintypmax_expression ]
end_edge_offset ::= mintypmax_expression
event_based_flag ::= expression
notifier ::= variable_identifier
reference_event ::= timing_check_event
remain_active_flag ::= expression
stamptime_condition ::= mintypmax_expression
start_edge_offset ::= mintypmax_expression
threshold ::= expression
timing_check_limit ::= expression
A.7.5.3 System timing check event definitions
timing_check_event ::=
[timing_check_event_control] specify_terminal_descriptor [ &&& timing_check_condition ]
controlled_timing_check_event ::=
timing_check_event_control specify_terminal_descriptor [ &&& timing_check_condition ]
timing_check_event_control ::=
posedge
| negedge
| edge_control_specifier
specify_terminal_descriptor ::=
specify_input_terminal_descriptor
| specify_output_terminal_descriptor
edge_control_specifier ::= edge [ edge_descriptor { , edge_descriptor } ]
edge_descriptor 2 ::=
01
| 10
| z_or_x zero_or_one
| zero_or_one z_or_x
zero_or_one ::= 0 | 1
z_or_x ::= x | X | z | Z
timing_check_condition ::=
scalar_timing_check_condition
| ( scalar_timing_check_condition )
scalar_timing_check_condition ::=
expression
| ~ expression
| expression == scalar_constant
| expression === scalar_constant
| expression != scalar_constant
| expression !== scalar_constant
scalar_constant ::=
1'b0 | 1'b1 | 1'B0 | 1'B1 | 'b0 | 'b1 | 'B0 | 'B1 | 1 | 0


*/



/*A.8 Expressions
A.8.1 Concatenations*/
concatenation :
	LBRACE expression comma_expression_list RBRACE
		{
			auto p=$3;
			p->push_front($2);
			$$=SHR2(concatenation,T_concatenation,(p));
		}
;

/*module_path_concatenation : 
	LBRACE module_path_expression comma_module_path_expression_list RBRACE
		{T_module_path_concatenation($2::$3)}
;

comma_module_path_expression_list :
	{[]}
	| comma_module_path_expression_list COMMA module_path_expression 
		{$1@[$3]}
;


module_path_multiple_concatenation :
	LBRACE expression module_path_concatenation RBRACE
		{T_module_path_multiple_concatenation($2,$3)}
;
*/
multiple_concatenation :
	LBRACE  expression concatenation RBRACE
		{$$=SHR2(multiple_concatenation,T_multiple_concatenation,($2,$3));}
;


/*A.8.2 Function calls*/

function_call :
	hierarchical_identifier attribute_instance_list
LPARENT expression comma_expression_list RPARENT
		{
			auto p=$5;
			p->push_front($4);
			$$=SHR2(function_call,T_function_call,($1,$2,p));
		}
;

system_function_call :
	system_function_identifier
lp_expression_comma_expression_list_rp_op
		{$$=SHR2(system_function_call,T_system_function_call,($1,$2));}
;


lp_expression_comma_expression_list_rp_op :
		{
			$$=SHR_LIST_SHR(expression)();
		}
	| LPARENT expression comma_expression_list RPARENT
		{
			auto p=$3;
			p->push_back($2);
			$$=p;
		}
;


/*A.8.3 Expressions*/
base_expression :
	expression {$$=$1;}
;

conditional_expression :
	expression OP2_QUESTION attribute_instance_list expression COLON expression
		{$$=SHR2(conditional_expression,T_conditional_expression,($1,$3,$4,$6));}
;

dimension_expression :
	expression
		{$$=$1;}
;

expression :
	primary
		{$$=SHR2(expression,T_expression_prim,($1));}
	| OP2_ADD  attribute_instance_list primary %prec OP1_ADD  {$$=SHR2(expression,T_expression_op1,(SHR2(unary_operator,T_unary_operator_ADD,()),$2,$3));}
	| OP2_SUB  attribute_instance_list primary %prec OP1_SUB  {$$=SHR2(expression,T_expression_op1,(SHR2(unary_operator,T_unary_operator_SUB,()),$2,$3));}
	| OP2_AND  attribute_instance_list primary %prec OP1_AND  {$$=SHR2(expression,T_expression_op1,(SHR2(unary_operator,T_unary_operator_REDUCE_AND,()) ,$2,$3));}
	| OP2_OR   attribute_instance_list primary %prec OP1_OR   {$$=SHR2(expression,T_expression_op1,(SHR2(unary_operator,T_unary_operator_REDUCE_OR,())  ,$2,$3));}
	| OP2_XOR  attribute_instance_list primary %prec OP1_XOR  {$$=SHR2(expression,T_expression_op1,(SHR2(unary_operator,T_unary_operator_REDUCE_XOR,()) ,$2,$3));}
	| OP2_XNOR attribute_instance_list primary %prec OP1_XNOR {$$=SHR2(expression,T_expression_op1,(SHR2(unary_operator,T_unary_operator_REDUCE_XNOR,()),$2,$3));}
	| OP1_LOGIC_NEG   attribute_instance_list primary {$$=SHR2(expression,T_expression_op1,(SHR2(unary_operator,T_unary_operator_LOGIC_NEG,())  ,$2,$3));}
	| OP1_BITWISE_NEG attribute_instance_list primary {$$=SHR2(expression,T_expression_op1,(SHR2(unary_operator,T_unary_operator_BITWISE_NEG,()),$2,$3));}
	| OP1_REDUCE_NAND attribute_instance_list primary {$$=SHR2(expression,T_expression_op1,(SHR2(unary_operator,T_unary_operator_REDUCE_NAND,()),$2,$3));}
	| OP1_REDUCE_NOR  attribute_instance_list primary {$$=SHR2(expression,T_expression_op1,(SHR2(unary_operator,T_unary_operator_REDUCE_NOR,()) ,$2,$3));}
	| expression OP2_MULTIPLE              attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator1,T_binary_operator_MUL,())                  ,$3,$4));}
	| expression OP2_DIV                   attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator1,T_binary_operator_DIV,())                  ,$3,$4));}
	| expression OP2_MOD                   attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator1,T_binary_operator_MOD,())                  ,$3,$4));}
	| expression OP2_EQU2                  attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator1,T_binary_operator_EQU2,())                 ,$3,$4));}
	| expression OP2_NEQ2                  attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator1,T_binary_operator_NEQ2,())                 ,$3,$4));}
	| expression OP2_EQU3                  attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator1,T_binary_operator_EQU3,())                 ,$3,$4));}
	| expression OP2_NEQ3                  attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator1,T_binary_operator_NEQ3,())                 ,$3,$4));}
	| expression OP2_POWER                 attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator1,T_binary_operator_POWER,())                ,$3,$4));}
	| expression OP2_LT                    attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator1,T_binary_operator_LT,())                   ,$3,$4));}
	| expression OP2_LE                    attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator1,T_binary_operator_LE,())                   ,$3,$4));}
	| expression OP2_GT                    attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator1,T_binary_operator_GT,())                   ,$3,$4));}
	| expression OP2_GE                    attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator1,T_binary_operator_GE,())                   ,$3,$4));}
	| expression OP2_LOGICAL_RIGHTSHIFT    attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator2,T_binary_operator_LOGICAL_RIGHTSHIFT,())   ,$3,$4));}
	| expression OP2_LOGICAL_LEFTSHIFT     attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator2,T_binary_operator_LOGICAL_LEFTSHIFT,())    ,$3,$4));}
	| expression OP2_ARITHMETIC_RIGHTSHIFT attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator2,T_binary_operator_ARITHMETIC_RIGHTSHIFT,()),$3,$4));}
	| expression OP2_ARITHMETIC_LEFTSHIFT  attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator2,T_binary_operator_ARITHMETIC_LEFTSHIFT,()) ,$3,$4));}
	| expression OP2_ADD                   attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator2,T_binary_operator_ADD,())                  ,$3,$4));}
	| expression OP2_SUB                   attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator2,T_binary_operator_SUB,())                  ,$3,$4));}
	| expression OP2_AND                   attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator2,T_binary_operator_AND,())                  ,$3,$4));}
	| expression OP2_OR                    attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator2,T_binary_operator_OR,())                   ,$3,$4));}
	| expression OP2_AND2                  attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator2,T_binary_operator_AND2,())                 ,$3,$4));}
	| expression OP2_OR2                   attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator2,T_binary_operator_OR2,())                  ,$3,$4));}
	| expression OP2_XOR                   attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator2,T_binary_operator_XOR,())                  ,$3,$4));}
	| expression OP2_XNOR                  attribute_instance_list expression {$$=SHR2(expression,T_expression_op2,($1,SHR3(binary_operator,binary_operator2,T_binary_operator_XNOR,())                 ,$3,$4));}
	| conditional_expression
		{$$=SHR2(expression,T_expression_condition,($1));}
;


mintypmax_expression :
	expression
		{$$=SHR2(mintypmax_expression,T_mintypmax_expression_1,($1));}
	| expression COLON expression COLON expression
		{$$=SHR2(mintypmax_expression,T_mintypmax_expression_3,($1,$3,$5));}
;

/*module_path_conditional_expression :
	module_path_expression OP2_QUESTION attribute_instance_list
	module_path_expression COLON module_path_expression
		{$$=SHR2(,T_module_path_conditional_expression,($1,$3,$4,$6));}
;


module_path_expression :
	module_path_primary
		{$$=SHR2(,T_module_path_expression_prim,($1);}
	| OP2_AND  attribute_instance_list module_path_primary %prec OP1_AND {$$=SHR2(,T_module_path_expression_op1,(SHR2(,T_unary_operator_REDUCE_AND,() ,$2,$3);}
	| OP2_OR   attribute_instance_list module_path_primary %prec OP1_OR  {$$=SHR2(,T_module_path_expression_op1,(SHR2(,T_unary_operator_REDUCE_OR,()  ,$2,$3);}
	| OP2_XOR  attribute_instance_list module_path_primary %prec OP1_XOR {$$=SHR2(,T_module_path_expression_op1,(SHR2(,T_unary_operator_REDUCE_XOR,() ,$2,$3);}
	| OP2_XNOR attribute_instance_list module_path_primary %prec OP1_XNOR{$$=SHR2(,T_module_path_expression_op1,(SHR2(,T_unary_operator_REDUCE_XNOR,(),$2,$3);}
	| OP1_LOGIC_NEG   attribute_instance_list module_path_primary {$$=SHR2(,T_module_path_expression_op1,(SHR2(,T_unary_operator_LOGIC_NEG,()  ,$2,$3);}
	| OP1_BITWISE_NEG attribute_instance_list module_path_primary {$$=SHR2(,T_module_path_expression_op1,(SHR2(,T_unary_operator_BITWISE_NEG,(),$2,$3);}
	| OP1_REDUCE_NAND attribute_instance_list module_path_primary {$$=SHR2(,T_module_path_expression_op1,(SHR2(,T_unary_operator_REDUCE_NAND,()       ,$2,$3);}
	| OP1_REDUCE_NOR  attribute_instance_list module_path_primary {$$=SHR2(,T_module_path_expression_op1,(SHR2(,T_unary_operator_REDUCE_NOR,()        ,$2,$3);}
	| module_path_expression OP2_EQU2 attribute_instance_list module_path_expression {$$=SHR2(,T_module_path_expression_op2,($1,SHR2(,T_binary_module_path_operator_EQU2,(),$3,$4);}
	| module_path_expression OP2_NEQ2 attribute_instance_list module_path_expression {$$=SHR2(,T_module_path_expression_op2,($1,SHR2(,T_binary_module_path_operator_NEQ2,(),$3,$4);}
	| module_path_expression OP2_AND2 attribute_instance_list module_path_expression {$$=SHR2(,T_module_path_expression_op2,($1,SHR2(,T_binary_module_path_operator_AND2,(),$3,$4);}
	| module_path_expression OP2_OR2  attribute_instance_list module_path_expression {$$=SHR2(,T_module_path_expression_op2(($1,SHR2(,T_binary_module_path_operator_OR2,() ,$3,$4);}
	| module_path_expression OP2_AND  attribute_instance_list module_path_expression {$$=SHR2(,T_module_path_expression_op2,($1,SHR2(,T_binary_module_path_operator_AND1,(),$3,$4);}
	| module_path_expression OP2_OR   attribute_instance_list module_path_expression {$$=SHR2(,T_module_path_expression_op2(($1,SHR2(,T_binary_module_path_operator_OR1,() ,$3,$4);}
	| module_path_expression OP2_XOR  attribute_instance_list module_path_expression {$$=SHR2(,T_module_path_expression_op2(($1,SHR2(,T_binary_module_path_operator_XOR,() ,$3,$4);}
	| module_path_expression OP2_XNOR attribute_instance_list module_path_expression {$$=SHR2(,T_module_path_expression_op2,($1,SHR2(,T_binary_module_path_operator_XNOR,(),$3,$4);}
	| module_path_conditional_expression
		{$$=SHR2(,T_module_path_expression_sel,($1);}
;


module_path_mintypmax_expression :
	module_path_expression
		{$$=SHR2(,T_module_path_mintypmax_expression_1,($1);}
	| module_path_expression COLON module_path_expression COLON module_path_expression
		{$$=SHR2(,T_module_path_mintypmax_expression_3,($1,$3,$5);}
;
*/

/*range_expression :*/
lsquare_range_expression_rsquare :
	LSQUARE expression RSQUARE
		{$$=SHR2(range_expression,T_range_expression_1,($2));}
	| LSQUARE expression COLON expression RSQUARE
		{$$=SHR2(range_expression,T_range_expression_2,($2,$4));}
	| LSQUARE base_expression ADDRANGE width_expression RSQUARE
		{$$=SHR2(range_expression,T_range_expression_addrange,($2,$4));}
	| LSQUARE base_expression SUBRANGE width_expression RSQUARE
		{$$=SHR2(range_expression,T_range_expression_subrange,($2,$4));}
;


width_expression :
	expression
		{$$=$1;}
;

/*A.8.4 Primaries*/

/*
module_path_primary :
	number
		{$$=SHR2(,T_module_path_primary_num,($1);}
	| identifier
		{$$=SHR2(,T_module_path_primary_id,($1);}
	| module_path_concatenation
		{$$=SHR2(,T_module_path_primary_concat,($1);}
	| module_path_multiple_concatenation
		{$$=SHR2(,T_module_path_primary_mul_concat,($1);}
	| function_call
		{$$=SHR2(,T_module_path_primary_func,($1);}
	| system_function_call
		{$$=SHR2(,T_module_path_primary_sysfunc,($1);}
	| LPARENT module_path_mintypmax_expression RPARENT
		{$$=SHR2(,T_module_path_primary_mintypmax,($2);}
;
*/
primary :
	number
		{$$=SHR2(primary,T_primary_num,($1));}
	| hierarchical_identifier 
		{$$=SHR2(primary,T_primary_id,($1));}
	| concatenation
		{$$=SHR2(primary,T_primary_concat,($1));}
	| multiple_concatenation
		{$$=SHR2(primary,T_primary_mulcon,($1));}
	| function_call
		{$$=SHR2(primary,T_primary_func,($1));}
	| system_function_call
		{$$=SHR2(primary,T_primary_sysfunc,($1));}
	| LPARENT mintypmax_expression RPARENT
		{$$=SHR2(primary,T_primary_mintypmax,($2));}
	| string_typedef
		{ $$=SHR2(primary,T_primary_string,($1));}
;

/*
lsq_expression_rsq_list :
	{[]}
	| lsq_expression_rsq_list square_expression_square
		{$1@[$2]}
;
square_expression_square :
	LSQUARE expression RSQUARE
		{$2}
;
*/

/*A.8.5 Expression left-side values*/
net_lvalue :
	hierarchical_identifier
		{$$=SHR2(net_lvalue,T_net_lvalue_id,($1));}
	| LBRACE net_lvalue comma_net_lvalue_list RBRACE
		{
			auto p=$3;
			p->push_front($2);
			$$=SHR2(net_lvalue,T_net_lvalue_lvlist,(p));
		}
;


comma_net_lvalue_list :
		{
			$$=SHR_LIST_SHR(net_lvalue)();
		}
	| comma_net_lvalue_list COMMA net_lvalue 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

/*variable_lvalue :
	hierarchical_variable_identifier 
		{T_variable_lvalue_id($1)}
	| hierarchical_variable_identifier lsq_expression_rsq_list lsquare_range_expression_rsquare
		{T_variable_lvalue_idexp($1,$2,$4)}
	| LBRACE variable_lvalue comma_variable_lvalue_list  RBRACE
		{T_variable_lvalue_vlvlist($2::$3)}
;		

comma_variable_lvalue_list :
	{[]}
	| comma_variable_lvalue_list COMMA variable_lvalue 
		{$1@[$3]}
;

*/

/*A.8.6 Operators*/


/*A.8.7 Numbers*/
number :
	UNSIGNED_NUMBER {$$=SHR2(number,T_number_UNSIGNED_NUMBER,($1));}
	| UNSIGNED_NUMBER_size {$$=SHR2(number,T_number_UNSIGNED_NUMBER_size,(get<0>($1) , get<1>($1)));}
	| OCTAL_NUMBER {$$=SHR2(number,T_number_OCTAL_NUMBER,(get<0>($1) , get<1>($1)));}
	| BINARY_NUMBER {$$=SHR2(number,T_number_BINARY_NUMBER,(get<0>($1) , get<1>($1)));}
	| HEX_NUMBER {$$=SHR2(number,T_number_HEX_NUMBER,(get<0>($1) , get<1>($1)));}
	| REAL_NUMBER {$$=SHR2(number,T_number_REAL_NUMBER,($1));}

/*A.8.8 Strings*/
string_typedef : STRING {$$=SHR2(string_typedef,T_string,($1));};


/*A.9 General
A.9.1 Attributes*/

attribute_instance : LPARENTSTART attr_spec  comma_attr_spec_list RPARENTSTART
	{
		auto p=$3;
		p->push_front($2);
		$$=SHR2(attribute_instance,T_attribute_instance,(p));
	}
;

comma_attr_spec_list :
		{
			$$=SHR_LIST_SHR(attr_spec)();
		}
	| comma_attr_spec_list COMMA attr_spec 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

attr_spec :
	attr_name 
		{$$=SHR2(attr_spec,T_attr_spec,($1,SHR2(expression,T_expression_NOSPEC,())));}
	| attr_name  EQU1 expression 
		{$$=SHR2(attr_spec,T_attr_spec,($1,$3));}
;

attr_name :
	identifier {$$=$1;}
;



/*A.9.2 Comments*/
/*comment :
	COMMENT {$1}
;
*/
/*A.9.3 Identifiers*/
block_identifier : identifier {$$=$1;};
/*cell_identifier : identifier {$1};
config_identifier : identifier {$1};*/
event_identifier : identifier {$$=$1;};
function_identifier : identifier {$$=$1;};
/*gate_instance_identifier : identifier {$1};*/
generate_block_identifier : identifier {$$=$1;};
genvar_identifier : identifier {$$=$1;};


hierarchical_identifier : 
	identifier_lsq_expression_rsq_opt_list  
		{$$=SHR2(hierarchical_identifier,T_hierarchical_identifier,($1));}
;
identifier_lsq_expression_rsq_opt_list :
	identifier_lsq_expression_rsq_opt 
		{
			auto p = SHR_LIST_SHR(identifier_lsq_expression_rsq)();
			p->push_back($1);
			$$=p;
		}
	| identifier_lsq_expression_rsq_opt_list PERIOD identifier_lsq_expression_rsq_opt 
		{
			auto p=$1;
			p->push_back($3);
			$$=p;
		}
;

identifier_lsq_expression_rsq_opt :
	identifier  lsquare_range_expression_rsquare_list
		{$$=SHR2(identifier_lsq_expression_rsq,T_identifier_lsq_expression_rsq,($1,$2));}
;
lsquare_range_expression_rsquare_list :
		{
			$$=SHR_LIST_SHR(range_expression)();
		}
	| lsquare_range_expression_rsquare_list lsquare_range_expression_rsquare
		{
			auto p=$1;
			p->push_back($2);
			$$=p;
		}
;

/*hierarchical_variable_identifier : hierarchical_identifier {$1};*/

identifier :
	SIMPLE_IDENTIFIER {$$=SHR2(identifier,T_identifier,($1));}
	| ESCAPED_IDENTIFIER {$$=SHR2(identifier,T_identifier,($1));}
;

/*inout_port_identifier : identifier {$$=$1;};
input_port_identifier : identifier {$$=$1;};
instance_identifier : identifier {$$=$1;};
library_identifier : identifier {$$=$1;};*/
module_identifier : identifier {$$=$1;};
module_instance_identifier : identifier {$$=$1;};
net_identifier : identifier {$$=$1;};
/*output_port_identifier : identifier {$$=$1;};*/
parameter_identifier : identifier {$$=$1;};
port_identifier : identifier {$$=$1;};
real_identifier : identifier {$$=$1;};
/*specparam_identifier : identifier {$$=$1;};*/


system_function_identifier :
	SYSTEM_TASK_FUNCTION_IDENTIFIER {
		$$=SHR2(system_function_identifier,T_system_function_identifier,($1));
	}
;


task_identifier : identifier {$$=$1;};
 /*terminal_identifier : identifier {$$=$1;};
text_macro_identifier : identifier {$$=$1;};
topmodule_identifier : identifier {$$=$1;};
udp_identifier : identifier {$$=$1;};
udp_instance_identifier : identifier {$$=$1;};*/
variable_identifier : identifier {$$=$1;};


%%
void
yy::verilog_parser::error (const location_type& l,
                          const std::string& m)
{
	std::cerr<<"FATAL : "<<m<<std::endl;
	std::cerr<<l<<std::endl;
}
