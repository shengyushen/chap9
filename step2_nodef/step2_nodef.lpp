%{
	#include<string>
	#include<iostream>
	#include<fstream>
	#include<stack>
	#include<assert.h>
	#include<regex>
	#include<unistd.h>
	#include<vector>
	#include<map>
	#include<chrono>

	using namespace std;

	class step2_nodefScanner : public step2_nodefFlexLexer {
	public :
		int linenumber ;
		int charnumber ;
		string filename ;
		step2_nodefScanner(const string & fn , ifstream * pis) :
			filename{fn},
			linenumber(1),
			charnumber(0),
			step2_nodefFlexLexer(pis)
		{ }
		int yylex();
		void print_pos_cerr () { cerr<< "print_pos_cerr " << filename << " : " << linenumber << " : " << charnumber << endl << flush; }
		void print_pos_cout () { cout<< "`line "<< (linenumber+1) << " " << filename << " 1" << endl << flush; }
		void incLineNumber (unsigned i=1) { linenumber=linenumber+i; charnumber=0 ; }
		void incCharNumber (int n) { charnumber+=n ; }
		void setPosition(int ln , string fn) {linenumber=ln;filename=fn;charnumber=0;}
	};

	void prt_fatal   (const string typ ,const string str)  { cerr<<"FATAL ["<<typ<<"] : "<<str<<endl<<flush; return; }
	void prt_info    (const string typ ,const string str)  { cerr<<"INFO  ["<<typ<<"] : "<<str<<endl<<flush; return; }
	void prt_warning (const string typ ,const string str)  { cerr<<"WARNING ["<<typ<<"] : "<<str<<endl<<flush; return; }

	//storing the map from macro name to body
	struct macrobody{
		vector<string> params;
		string body;
	};
	string currentMacroName;
	map<string,macrobody> macros;
	bool isInMacro(string mname) {
		if((macros.find(mname)) == (macros.end())) return false;
		else return true;
	}
	void insertMacro(string macroname, macrobody macrobody_inst) {
		if(isInMacro(macroname)) {
			prt_warning ("PREPROC_1001","redefined macro "+macroname);
			auto x = macros.find(macroname);
			x->second=macrobody_inst;
		} else {
			macros.insert( make_pair ( macroname , macrobody_inst )  );
		}
	}
	bool isBlank(char c) {
		if(c==' ') return true;
		else if (c=='\t') return true;
		else if (c=='\n') return true;
		else if (c=='\r') return true;
		else return false;
	}
	bool isIDheadchar (char c) {
		if('a' <= c && c <= 'z') return true;
		else if('A' <= c && c <= 'Z') return true;
		else if(c == '_') return true;
		else if(c == '\\') return true;
		else return false;
	}
	bool isIDnonHeadChar (char c ) {
		if('a' <= c && c <= 'z') return true;
		else if('A' <= c && c <= 'Z') return true;
		else if(c == '_') return true;
		else if ('0' <= c && c <= '9') return true;
		else return false;
	}
	size_t searchID(const string body , const size_t pos1) {
		cerr<<"searchID in "<<body<<" at pos "<<pos1<<endl;
		size_t pos=pos1;
		if( isIDheadchar (body[pos] ) ) {
			if(body[pos]=='\\') {
				//escaped_identifier
				cerr<<"escaped_identifier"<<endl;
				while(isBlank(body[pos])==false && pos<body.size()) {pos++; cerr<<pos<<endl;}
				pos--;
				return pos;
			} else {
				//simple_identifier
				cerr<<"simple_identifier"<<endl;
				pos++;
				while(isIDnonHeadChar(body[pos]) && pos< body.length()) {pos++;}
				pos--;
				return pos;
			}
		} else {
			prt_fatal("PREPROC_1002","searchID start with non head char");
			exit(1);
		}
	}
	void replaceBody(string &body , const vector<string> &formallist ,const vector<string> &pamvec) {
		//construct a map
		vector<string> newfmlst = formallist;
		vector<string> newpamlst = pamvec;
		map<string,string> mm;
		while(newfmlst.empty()==false) {
			string fm = newfmlst.back();
			newfmlst.pop_back();
			string pam = newpamlst.back();
			newpamlst.pop_back();
			mm.insert(make_pair(fm,pam));
		}

		size_t last_pos=0;
		while(last_pos<body.length()) {
			if(isIDheadchar(body[last_pos])) {
				size_t postail = searchID(body,last_pos);
				string newsub=body.substr(last_pos,postail-last_pos+1);
				auto mmit=mm.find(newsub);
				if(mmit==mm.end()) { last_pos=postail+1;}
				else {
					body.replace(last_pos,postail-last_pos+1,mmit->second);
					last_pos=last_pos+((mmit->second).length());
				}
			} else {
				last_pos++;
			}
		}
	}
	vector<string> splitStringChar(const string s ,  const char sep) {
		vector<string> vs;
		size_t bg=0;
		int nest=0;
		for(size_t i=0 ; i< s.length() ;i++) {
			if(nest<0) {
				prt_fatal("PREPROC_1003","unmatched () in : "+s);
				exit(1);
			}

			if(s[i]=='(') nest++;
			else if(s[i]==')') nest--;

			if( sep == s[i] && nest==0) { //must only use sep when () is matched
				if(i==bg) {
					vs.push_back("");
				} else {
					vs.push_back(s.substr(bg,i-bg));
				}
				bg=i+1;
			}
		}
		if(bg== s.length()) {
			//this means we have sep in last of s
			assert(s[s.length()-1] == sep);
			vs.push_back("");
		} else if(bg==0) {
			//this means we have NOT met a sep
			assert(vs.size()==0);
			vs.push_back(s);
		} else {
			vs.push_back(s.substr(bg,(s.length())-bg));
		}
		return vs;
	}
	void deleteblank(string & s) {
		while((s[0]==' '|| s[0]=='\t') && (s.length()>0))  {s.erase(0,1);}
		while(isBlank(s[s.length()-1])&& (s.length()>0))  {s.pop_back();}
	}
	unsigned deleteBackslach(string & s) {
		unsigned del=0;
		cerr<<"deleteBackslach in :"<<s<<endl;
		while(true) {
			auto pos = s.find("\\\n");
			if(pos==string::npos) {
				cerr<<"deleteBackslach out :"<<s<<endl;
				return del;
			} else {
				s.erase(pos,1);
				del++;
				cerr<<"deleteBackslach delete :"<<s<<endl;
			}
		}
	}
	size_t searchRParentMatched(const string & s,const size_t pos1) {
		size_t pos=pos1;
		int nest=0;
		while((pos<s.size())) {
			if(nest<0) {
				prt_fatal("PREPROC_1004","unmatched () in : "+s);
				exit(1);
			}
			if(s[pos]=='(') {
				nest++;
			} else if(s[pos]==')') {
				if(nest==1) return pos;//the last matched right parent
				else nest--;
			} 
			pos++;
		}
		if(pos!=0) {
			prt_fatal("PREPROC_1005","unmatched () in : "+s);
			exit(0);
		}
	}
	void replaceMacro(string & body , string fn, int ln) {
		size_t last_pos=0;
		while(last_pos<body.length()) {
			size_t pos = body.find('`', last_pos);
			if(pos==string::npos) {
				//no more macros
				return ;
			} else if(pos==body.length()-1) {
				//last char
				prt_fatal ("PREPROC_1006","` at the last postion ");
				cerr<<fn<<" : "<<ln<<endl<<flush;
				exit(1);
			} else if(isIDheadchar(body[pos+1])) {
				size_t postail = searchID(body , pos+1);
				string nm = body.substr(pos+1,postail-(pos+1)+1);
				if(isInMacro(nm)) {
					auto mp = (macros.find(nm))->second;
					if((mp.params).size()==0) {
						//no parameter direct replace
						body.replace(pos,postail-pos+1,mp.body);
						last_pos = 0;//restart from head
					} else {
						//have parameter
						//find (
						size_t lppos=body.find('(',postail);
						if(lppos==string::npos) {
							prt_fatal("PREPROC_1007","macro "+nm+" should have parameter list with (");
							cerr<<fn<<" : "<<ln<<endl<<flush;
							exit(1);
						}
						size_t rppos = searchRParentMatched(body,lppos);
						if(rppos==string::npos) {
							prt_fatal("PREPROC_1008","macro "+nm+" should have parameter list with )");
							cerr<<fn<<" : "<<ln<<endl<<flush;
							exit(1);
						}

						//now we have a list of parameter
						string paramstring = body.substr(lppos,rppos-lppos+1);
						assert(paramstring[0]=='(');
						assert(paramstring[paramstring.length()-1]==')');
						paramstring.erase(0,1);
						paramstring.pop_back();
						vector<string> pamvec = splitStringChar(paramstring , ',');
						for(auto & s : pamvec) {deleteblank(s);}
						
						//now we have the parameter vector in pamvec
						//and mp is the macrobody
						if((mp.params).size()!=pamvec.size()) {
							prt_fatal("PREPROC_1009","length of macro "+nm+"'s parameter list are not the same");
							cerr<<fn<<" : "<<ln<<endl<<flush;
							exit(1);
						}

						string newbody=mp.body;
						vector<string> newformallist = mp.params;
						replaceBody(newbody , newformallist , pamvec);
						body.replace(pos,rppos-pos+1,newbody);
						last_pos = 0 ;//restart
					}
				} else {
					prt_fatal("PREPROC_1010","not defined macro "+nm);
					cerr<<fn<<" : "<<ln<<endl<<flush;
					exit(1);
				}
			} else {
				//not an id
				last_pos = pos+1;
			}
		}
		return;
	}
	
	void usage() {
		cerr<<"step2_nodef [input filename] -I [head file dir] -I ..."<<endl;
		return;
	}
	
	bool testFileExistenceInDir(string dirname_filename) {
		ifstream foo( dirname_filename );
		return foo.is_open();
	}

	//related to `line
	int ln;
%}

%option noyywrap
%option yylineno
 /*these are command line transfer to here*/
%option outfile="step2_nodef.cpp"
%option warn
%option c++
%option prefix="step2_nodef"
%option yyclass="step2_nodefScanner"
%option header-file="step2_nodef.h"

string \"[^\n"]+\"
alpha [A-Za-z]
digit [0-9]
blank [ \t]
alnum {alpha}|{digit}
alnum_ {alnum}|[_]
alpha_ {alpha}|[_]

escaped_identifier     \\[^ \t\n]+[ \t\n\r]
simple_identifier  [a-zA-Z_][a-zA-Z0-9_\$]*
identifier_comb {escaped_identifier}|{simple_identifier}

useless_directive "`default_decay_time"|"`default_trireg_strength"|"`delay_mode_distributed"|"`delay_mode_path"|"`delay_mode_unit"|"`delay_mode_zero"|"`accelerate"|"`autoexpand_vectornets"|"`begin_keywords"|"`celldefine"|"`default_nettype"|"`endcelldefine"|"`end_keywords"|"`endprotect"|"`endprotected"|"`expand_vectornets"|"`noaccelerate"|"`noexpand_vectornets"|"`noremove_gatenames"|"`noremove_netnames"|"`nounconnected_drive"|"`pragma"|"`protect"|"`protected"|"`remove_gatenames"|"`remove_netnames"|"`resetall"|"`timescale"|"`unconnected_drive"


%x macro proc_ifdef do_then proc_ifndef line_skip_blank line_number line_skip_blank2 line_filename endofline proc_undef do_else do_else_in skip_else proc_ifdef_inskip

%%
\r 

\n	{
	ECHO;

	this->incLineNumber();
}

"`define"{blank}+{identifier_comb} {
	string s(yytext);

	s.erase(0,7);
	deleteblank(s);
	cerr<<s<<endl;
	currentMacroName=s;

	yy_push_state(macro);
}

"`ifdef" {
	string s(yytext);

	yy_push_state(proc_ifdef);
}

"`ifndef" {
	string s(yytext);

	yy_push_state(proc_ifndef);
}

"`else"|"elsif" {
	string s(yytext);

	prt_fatal("PREPROC_1011","mismatched "+s);
	exit(1);
}

"`endif" {
	string s(yytext);

	prt_fatal("PREPROC_1012","mismatched "+s);
	exit(1);
}

"`undef"				{
	string s(yytext);

	yy_push_state(proc_undef);
}

{useless_directive} {
	string s(yytext);
	incCharNumber(s.size());

	prt_warning("PREPROC_1013","useless_directive "+s);
	print_pos_cerr ();
	ECHO;
}

"`include"{blank}*"\"".*"\""+ {
	string s{yytext};
	prt_fatal("PREPROC_1014","can not found included file\n"+s);
	print_pos_cerr ();
	exit(1);
}

"`line"			{
	string s(yytext);

	ECHO;
	yy_push_state(line_skip_blank);
}

[`]{identifier_comb}{blank}*[(]({blank}*[^\n\r,]+{blank}*[,])*{blank}*[^\n\r,]+{blank}*[)] {
	//replacing macros
	string s(yytext);
	int oldsize = s.size();

	cerr<<"wo "<<s<<endl;
	int lppos = s.find('(',1);
	int rppos = s.size()-1;
	assert(s[rppos]==')');
	string oldbody = s.substr(0,rppos+1);
	replaceMacro(oldbody , filename , linenumber);
	cout<<oldbody;
	incCharNumber(oldbody.size()-oldsize);
}

[`]{identifier_comb} {
	string s(yytext);
	int oldsize = s.size();

	s.erase(0,1);
	deleteblank(s);
	if(isInMacro(s) == false) {
		prt_fatal("PREPROC_1015","undefined macro "+s);
		print_pos_cerr ();
		exit(1);
	}
	//now we have defined
	auto mp = (macros.find(s))->second;
	if((mp.params).size()!=0) {
		prt_fatal("PREPROC_1016","mismatching parameter length of macro "+s);
		print_pos_cerr ();
		exit(1);
	}
	string oldbody = mp.body;
	replaceMacro(oldbody , filename , linenumber);
	cout<<oldbody;
	incCharNumber(mp.body.size()-oldsize);
}

[ \ta-zA-Z0-9]+ {
	ECHO;
	string s(yytext);
	incCharNumber(s.size());
}

. {
	ECHO;
	string s(yytext);
	incCharNumber(s.size());
}

<proc_ifdef>{
	{blank}+ 

	{identifier_comb} {
		string s{yytext};
		deleteblank(s);
		if(isInMacro(s)) {
			yy_pop_state();
			yy_push_state(do_then);
		} else {
			yy_pop_state();
			yy_push_state(do_else);
		}
	}

	. {prt_fatal("PREPROC_1017","improper ifdef statement");exit(1);}
}

<proc_ifndef>{
	{blank}+ 

	{identifier_comb} {
		string s{yytext};
		deleteblank(s);
		if(isInMacro(s)) {
			yy_pop_state();
			yy_push_state(do_else);
		} else {
			yy_pop_state();
			yy_push_state(do_then);
		}
	}

	. {prt_fatal("PREPROC_1018","improper ifndef statement");exit(1);}
}

<do_then>{
	\r 

	\n {
		ECHO;
		incLineNumber();
	}
	
	"`ifdef" {
		yy_push_state(proc_ifdef);
	}

	"`ifndef" {
		yy_push_state(proc_ifndef);
	}

	"`else" {
		yy_pop_state();
		yy_push_state(skip_else);
	}

	"`elsif" {
		yy_pop_state();
		yy_push_state(skip_else);
	}

	"`endif" {
		print_pos_cout ();
		yy_pop_state();
	}

	"`define"{blank}+{identifier_comb} {
		string s(yytext);

		s.erase(0,7);
		deleteblank(s);
		cerr<<s<<endl;
		currentMacroName=s;

		yy_push_state(macro);
	}
	
	"`undef"				{
		yy_push_state(proc_undef);
	}

	{useless_directive} {
		string s(yytext);
		incCharNumber(s.size());
		prt_warning("PREPROC_1019","useless_directive "+s);
		print_pos_cerr ();
		ECHO;
	}
	
	"`line"			{
		ECHO;
		yy_push_state(line_skip_blank);
	}
	
	
	[`]{identifier_comb}{blank}*[(]({blank}*[^\n\r,]+{blank}*[,])*{blank}*[^\n\r,]+{blank}*[)] {
		//replacing macros
		string s(yytext);
		int oldsize = s.size();
		cerr<<"wo "<<s<<endl;
		int lppos = s.find('(',1);
		int rppos = s.size()-1;
		assert(s[rppos]==')');
		string oldbody = s.substr(0,rppos+1);
		replaceMacro(oldbody , filename , linenumber);
		cout<<oldbody;
		incCharNumber(oldbody.size()-oldsize);
	}
	
	[`]{identifier_comb} {
		string s(yytext);
		int oldsize = s.size();

		s.erase(0,1);
		deleteblank(s);
		if(isInMacro(s) == false) {
			prt_fatal("PREPROC_1020","undefined macro "+s);
			print_pos_cerr ();
			exit(1);
		}
		//now we have defined
		auto mp = (macros.find(s))->second;
		if((mp.params).size()!=0) {
			prt_fatal("PREPROC_1021","mismatching parameter length of macro "+s);
			print_pos_cerr ();
			exit(1);
		}
		string oldbody = mp.body;
		replaceMacro(oldbody , filename , linenumber);
		cout<<oldbody;
		incCharNumber(mp.body.size()-oldsize);
	}
	
	[ \ta-zA-Z0-9]+ {
		ECHO;
		string s(yytext);
		incCharNumber(s.size());
	}
	
	. {
		ECHO;
		string s(yytext);
		incCharNumber(s.size());
	}
} 

<line_skip_blank>{
	{blank}+ {
		ECHO;
		yy_pop_state();
		yy_push_state(line_number);
	}
	. {prt_fatal("PREPROC_1022","improper `line statement");exit(1);}
}

<line_number>{
	{digit}+ {
		sscanf(yytext,"%d",&ln);
		ECHO;
		yy_pop_state();
		yy_push_state(line_skip_blank2);
	}

	. {prt_fatal("PREPROC_1023","improper `line number");exit(1);}
}

<line_skip_blank2>{
	{blank}+ {
		ECHO;
		yy_pop_state();
		yy_push_state(line_filename);
	}
	. {prt_fatal("PREPROC_1024","improper `line file name");exit(1);}
}

<line_filename>{
	[^\n\t ]+ {
		string s{yytext};
		setPosition(ln-1,s);
		ECHO;
		yy_pop_state();
		yy_push_state(endofline);
	}

	. {prt_fatal("PREPROC_1025","improper `line file name 2");exit(1);}
}


<do_else>{
	\r 

	\n {
		incLineNumber();
	}

	"`ifdef"|"`ifndef" {
		yy_push_state(proc_ifdef_inskip);
	}

	"`else" {
		yy_pop_state();
		yy_push_state(do_else_in);
	}

	"`elsif" {
		yy_pop_state();
		yy_push_state(proc_ifdef);
	}

	"`endif" {
		print_pos_cout ();
		yy_pop_state();
	}

	[ \ta-zA-Z0-9]+ {
		string s(yytext);
		incCharNumber(s.size());
	}
	
	. {
		string s(yytext);
		incCharNumber(s.size());
	}
	
}

<do_else_in>{
	\r 

	\n {
		ECHO;
		incLineNumber();
	}

	"`define"{blank}+{identifier_comb} {
		string s(yytext);

		s.erase(0,7);
		deleteblank(s);
		cerr<<s<<endl;
		currentMacroName=s;

		yy_push_state(macro);
	}

	"`ifdef" {
		yy_push_state(proc_ifdef);
	}

	"`ifndef" {
		yy_push_state(proc_ifndef);
	}

	"`else"|"elsif" {
		string s(yytext);
		prt_fatal("PREPROC_1026","mismatched "+s);
		exit(1);
	}

	"`endif" {
		print_pos_cout ();
		yy_pop_state();
	}

	"`undef"				{
		yy_push_state(proc_undef);
	}

	{useless_directive} {
		string s(yytext);
		incCharNumber(s.size());
		prt_warning("PREPROC_1027","useless_directive "+s);
		print_pos_cerr ();
		ECHO;
	}

	"`line"			{
		ECHO;
		yy_push_state(line_skip_blank);
	}
	
	[`]{identifier_comb}{blank}*[(]({blank}*[^\n\r,]+{blank}*[,])*{blank}*[^\n\r,]+{blank}*[)] {
		//replacing macros
		string s(yytext);
		int oldsize = s.size();

		cerr<<"wo "<<s<<endl;
		int lppos = s.find('(',1);
		int rppos = s.size()-1;
		assert(s[rppos]==')');
		string oldbody = s.substr(0,rppos+1);
		replaceMacro(oldbody , filename , linenumber);
		cout<<oldbody;
		incCharNumber(oldbody.size()-oldsize);
	}
	
	[`]{identifier_comb} {
		string s(yytext);
		int oldsize = s.size();

		s.erase(0,1);
		deleteblank(s);
		if(isInMacro(s) == false) {
			prt_fatal("PREPROC_1028","undefined macro "+s);
			print_pos_cerr ();
			exit(1);
		}
		//now we have defined
		auto mp = (macros.find(s))->second;
		if((mp.params).size()!=0) {
			prt_fatal("PREPROC_1029","mismatching parameter length of macro "+s);
			print_pos_cerr ();
			exit(1);
		}
		string oldbody = mp.body;
		replaceMacro(oldbody , filename , linenumber);
		cout<<oldbody;
		incCharNumber(mp.body.size()-oldsize);
	}
	
	[ \ta-zA-Z0-9]+ {
		ECHO;
		string s(yytext);
		incCharNumber(s.size());
	}
	
	. {
		ECHO;
		string s(yytext);
		incCharNumber(s.size());
	}
	
}

<skip_else>{
	\r 
	
	\n	{
		/*counting lines*/
		this->incLineNumber();
	}

	"`ifdef"|"`ifndef" {
		yy_push_state(proc_ifdef_inskip);
	}

	"`endif" {
		print_pos_cout ();
		yy_pop_state();
	}

	[ \ta-zA-Z0-9]+ {
		string s(yytext);
		incCharNumber(s.size());
	}
	
	. {
		string s(yytext);
		incCharNumber(s.size());
	}
}

<proc_ifdef_inskip>{
	\r 

	\n {
		incLineNumber();
	}

	"`ifdef"|"`ifndef" {
		yy_push_state(proc_ifdef_inskip);
	}

	"`endif" {
		yy_pop_state();
	}

	[ \ta-zA-Z0-9]+ {
		string s(yytext);
	}
	
	. {
		string s(yytext);
	}
	
}

<proc_undef>{
	{blank}+ 
	{identifier_comb} {
		string s{yytext};
		deleteblank(s);
		if(isInMacro(s)) {
			macros.erase(s);
			yy_pop_state();
		} else {
			prt_warning("PREPROC_1030","undefining macro "+s+" that have not been defined");
			yy_pop_state();
		}
	}

	. {prt_fatal("PREPROC_1031","improper undef statement");exit(1);}
}

<endofline>{
	[^\n]*\n {
		incLineNumber();
		ECHO;
		yy_pop_state();
	}
}

<macro>{
	[(]({blank}*{simple_identifier}{blank}*[,])*{blank}*{simple_identifier}{blank}*[)]([^\n]|"\\\n")*\n {
		// (arg1,arg2,...) <macro body> 
		// where <macro body> contains < backslash +\n>
		string s(yytext);
		s.pop_back();//removing the return
		deleteblank(s);//removing all blanks
		auto num_del_backslash=deleteBackslach(s); //deleting backslash before \n
		assert(s[0]=='(');
		size_t rppos = searchRParentMatched(s,0);//find )
		string paramlist = s.substr(1,rppos-1); // arg1,arg2,...
		vector<string> vs=splitStringChar(paramlist , ',');//list of args
		for(auto & s : vs) {deleteblank(s);} //deleting blank for each args
		for(auto & s : vs) {cerr << "param "<<s<<"X\n";}
		macrobody mb;
		mb.params = vs;//setting args
		string body = s.substr(rppos+1,(s.length()-1-(rppos+1)+1));//<macro body>
		deleteblank(body);//deleting blank for <macro body>
		//should not replace now, verilog 2005 
		// require us to replace only when using this macro
		//replaceMacro(body , filename , linenumber );
		mb.body = body;
		insertMacro(currentMacroName,mb);
		cerr<<"macro name : "<<currentMacroName<<endl;
		cerr<<"macro body : "<<body<<endl;
		incLineNumber(num_del_backslash+1);
		print_pos_cout();
		yy_pop_state();
	}

	([^\n]|"\\\n")*\n {
		// <macro body> only
		string s {yytext};
		s.pop_back();//removing return
		deleteblank(s);//removing blank
		auto num_del_backslash=deleteBackslach(s); //deleting backslash before \n
		//should not replace now, verilog 2005 
		// require us to replace only when using this macro
		//replaceMacro(s , filename , linenumber );
		macrobody mb;
		mb.params.clear();
		mb.body=s;
		insertMacro(currentMacroName,mb);
		cerr<<"macro name : "<<currentMacroName<<endl;
		cerr<<"multi-line macro body without param : "<<s<<endl;
		incLineNumber(num_del_backslash+1);
		print_pos_cout();
		yy_pop_state();
	}

	\n {
		cerr<<"macro name : "<<currentMacroName<<endl;
		cerr<<"macro body without param "<<endl;
		macrobody mb;
		mb.params.clear();
		mb.body="";
		insertMacro(currentMacroName,mb);
		incLineNumber();
		yy_pop_state();
	}

	. {prt_fatal("PREPROC_1032","improper define");exit(1);}
}

%%



extern char *optarg;
extern int optind, optopt, opterr;
int main ( int argc, char * argv[] ) {
	std::chrono::time_point<std::chrono::system_clock> start, end;
	start = std::chrono::system_clock::now();
	std::time_t st_time = std::chrono::system_clock::to_time_t(start);
	std::cerr << "step2 start computation at " << std::ctime(&st_time);

	//handling options
	int c;
	while ((c = getopt (argc, argv, "D:")) != -1) {
		switch (c)
		{
		case 'D': {
			string macroname{optarg};
			macrobody mb;
			mb.params.clear();
			mb.body="";
			insertMacro ( macroname , mb );
			}
			break;
		case '?' : {
			if (optopt == 'I')
				cerr << "Option -" <<optopt << " requires an argument.\n";
			else if (isprint (optopt))
				cerr << "Unknown option `-" << optopt << "'.\n";
			else
				cerr << "Unknown option character `\\xi" << optopt << "'.\n";
			usage();
			}
			return 1;
		default:
			usage();
			return 1;
		}
	}

	if(optind<argc-1)  {
		prt_fatal ("PREPROC_1033", "only allow 1 filename");
		usage();
		return 1;
	}

	//testing existence of file
	if( false == testFileExistenceInDir(argv[argc-1])) {
	   prt_fatal ("PREPROC_1034", "input file doesn't exist " ) ;
		 return 1;
	}

	ifstream foo( argv[argc-1] );
	//creating files handler and scanner
	step2_nodefScanner * lexer= new step2_nodefScanner(argv[argc-1],&foo);
	while(lexer->yylex()!=0) {
		prt_fatal ("PREPROC_1035","improper return");
		cout<<"// return here\n"<<flush;
	}
	
	end = std::chrono::system_clock::now();
	std::chrono::duration<double> elapsed_seconds = end-start;
	std::time_t end_time = std::chrono::system_clock::to_time_t(end);
	std::cerr << "step2 finished computation at " << std::ctime(&end_time)
	<< "elapsed time: " << elapsed_seconds.count() << "s\n";

	return 0;
}

